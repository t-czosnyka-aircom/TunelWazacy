<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.13">
  <POU Name="fbChiniseMachine_v2" Id="{5dc1cd30-fd90-4a4f-a263-1118ec734c57}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK fbChiniseMachine_v2 IMPLEMENTS I_StationMachine
VAR_INPUT
	stSlaveParms				: stModTcpSlaveParams;
	bNextMachineWork			: BOOL;
END_VAR
VAR_OUTPUT
END_VAR
VAR
	I_PimSystem					: I_PIM;
	I_ModbusTcpCommunication 	: I_ModbusTcpCore;
	iWorkStep 					: INT;
	bServiceReset				: BOOL;
	stPimCommunicationData		: stPimMachineData;
	stModbusTcpData				: stModTcpQue;
	fbResetWaitTime				: TON;
	fbWorkEnded					: R_TRIG;					// Rising edgre reaction for end of cycle 
	iLastPartsRecord			: WORD;
	arReadArray					: ARRAY[0..GVL_ModbusTCP_Constants.iWriteRegisterLimit] OF INT;
	arWriteArray				: ARRAY[0..GVL_ModbusTCP_Constants.iWriteRegisterLimit] OF INT;
	rCommIntervalCounter		: REAL;
	nLastOperationStatus		: nModbusTCP_CommandStatus;
	fbCommunicationTimeout		: TON;
	bLastLifeBitState			: BOOL;
	stHMI						: stChiniseMachineHmiData;
	fbLifeBitPLC				: TON;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[ACT_Background();

CASE iWorkStep OF
	0:	// Init
		iWorkStep := 5;
	5:	// Wait for next state
		I_PimSystem.mSetNewMachineState(nPIM_MachineStates._2_ReadyForNewOperation);	
		iWorkStep := 10;
	10: // Start of work
		IF stPimCommunicationData.wGoodPartsAmount > iLastPartsRecord AND stSlaveParms.bPartsCount THEN
			IF I_PimSystem.mSetNewMachineState(nPIM_MachineStates._3_NewOperationStarted) THEN
				iLastPartsRecord := iLastPartsRecord +1;
				iWorkStep := 15;
				I_PimSystem.mSetNewMachineState(nPIM_MachineStates._4_OperationInProgress);
			END_IF
		END_IF
	15:	// Work ended
			iWorkStep := 5;
			I_PimSystem.mSetNewMachineState(nPIM_MachineStates._5_OperationEndedOK);
	90:	// Wysterowanie w przypadku błędu
		I_PimSystem.mSetNewMachineState(nPIM_MachineStates._8_WaitForReset);
		iWorkStep := 91;
	91:	// Oczekiwanie na reset
		IF I_PimSystem.mSetNewMachineState(nPIM_MachineStates._9_ResetInProgress) OR bServiceReset THEN
			bServiceReset := FALSE;
			stPimCommunicationData.bResetError := TRUE;
			fbCommunicationTimeout(IN:=FALSE);
			fbResetWaitTime(IN:=FALSE);
			iWorkStep := 92;
		END_IF
	92: // Wait some time
		fbResetWaitTime(IN:=TRUE,PT:=T#2S);
		IF fbResetWaitTime.Q THEN
			fbResetWaitTime(IN:=FALSE,PT:=T#2S);
			stPimCommunicationData.bResetError := FALSE;
			stPimCommunicationData.bConfirmError := TRUE;
			iWorkStep := 93;
		END_IF
	93:	// Check error state
		fbResetWaitTime(IN:=TRUE,PT:=T#2S);
		IF NOT stPimCommunicationData.bError THEN
			stPimCommunicationData.bConfirmError := FALSE;
			iWorkStep := 95;
			fbResetWaitTime(IN:=TRUE,PT:=T#2S);
		ELSIF fbResetWaitTime.Q THEN
			fbResetWaitTime(IN:=TRUE,PT:=T#2S);
			stPimCommunicationData.bResetError := FALSE;
			stPimCommunicationData.bConfirmError := FALSE;
			mNewEvent(nEventClass:=nPIM_EventClasses.Error,nEvent:=stPimCommunicationData.iErrorCode+stSlaveParms.iErrorOffset);
		END_IF
	95: // Potwierdzenie błędu itp
		I_PimSystem.mSetNewMachineState(nPIM_MachineStates._0_Standby_NotReady);
		stPimCommunicationData.bResetError := FALSE;
		stPimCommunicationData.bConfirmError := FALSE;
		iWorkStep := 5;
	
END_CASE]]></ST>
    </Implementation>
    <Action Name="ACT_Background" Id="{ac6be33c-aedc-42f7-ae6a-ee1121849d74}">
      <Implementation>
        <ST><![CDATA[//Block parametrization form parameters
stModbusTcpData.sIpAdress 					:= stSlaveParms.sIpAdress;
stModbusTcpData.iPort 						:= stSlaveParms.iPort;
stModbusTcpData.iUnitId 					:= stSlaveParms.iUnitId;
stModbusTcpData.wRegistersReadQuantity		:= stSlaveParms.iRegisterReadAmount;
stModbusTcpData.wRegistersWriteQuantity		:= stSlaveParms.iRegisterWriteAmount;
stModbusTcpData.sMachineIndifiner			:= stSlaveParms.sMachineIdenfier;
stModbusTcpData.iRegisterReadStartAdress	:= stSlaveParms.iRegisterReadStartAdress;
stModbusTcpData.iRegisterWriteStartAdress	:= stSlaveParms.iRegisterWriteStartAdress;
//Rewrite signals from PIM System
//stMachineModbusParams.stPimData.bOfflineWorkAllow :=FALSE;
stPimCommunicationData.bStopPerform:=NOT bNextmachineWork;
stPimCommunicationData.bTestMode:=I_PimSystem.prTestMode;
stPimCommunicationData.bWaitWithWork:=I_PimSystem.prPlcBlockWork;
stPimCommunicationData.bWorkAllow:=I_PimSystem.prWorkPermission ;
//Rewrite signals - signal for Lifebit
// Need to add iPartsCreatedInOneTime!!!

fbLifeBitPLC(IN:=NOT fbLifeBitPLC.Q ,PT:=T#500MS);

//Triggers
fbWorkEnded(CLK:=stPimCommunicationData.bCycleEnd);
//Data to send to slave

arWriteArray[0]			:= stPimCommunicationData.iProductId;
arWriteArray[10]		:= BOOL_TO_INT(stPimCommunicationData.bLifeBitPLC);
arWriteArray[11]		:= BOOL_TO_INT(stPimCommunicationData.bWorkAllow);
arWriteArray[12]		:= BOOL_TO_INT(stPimCommunicationData.bResetError);
arWriteArray[13]		:= BOOL_TO_INT(stPimCommunicationData.bConfirmError);
arWriteArray[14]		:= BOOL_TO_INT(stPimCommunicationData.bTestMode);
arWriteArray[15]		:= BOOL_TO_INT(stPimCommunicationData.bStopPerform);
arWriteArray[18]		:= BOOL_TO_INT(stPimCommunicationData.bWaitWithWork);
arWriteArray[19]		:= BOOL_TO_INT(stPimCommunicationData.bOfflineWorkAllow);


//Data to read form slave
stPimCommunicationData.iActualWorkStep			:= arReadArray[0];
stPimCommunicationData.wGoodPartsAmount			:= INT_TO_WORD(arReadArray[1]*256+arReadArray[2]);
stPimCommunicationData.wBadPartsAmount			:= INT_TO_WORD(arReadArray[3]*256+arReadArray[4]);
stPimCommunicationData.iCycleTime				:= arReadArray[5];
stPimCommunicationData.iPartsCreatedInOneTime	:= arReadArray[6];
stPimCommunicationData.iErrorCode				:= arReadArray[7];
stPimCommunicationData.bLifeBitMachine			:= INT_TO_BOOL(arReadArray[10]);
stPimCommunicationData.bWorkInProgress			:= INT_TO_BOOL(arReadArray[11]);
stPimCommunicationData.bCycleEnd				:= INT_TO_BOOL(arReadArray[12]);
stPimCommunicationData.bError					:= INT_TO_BOOL(arReadArray[13]);
stPimCommunicationData.bAlarm					:= INT_TO_BOOL(arReadArray[14]);	
			
//Add command to que 
IF stSlaveParms.bCommunicationActive THEN
	rCommIntervalCounter := rCommIntervalCounter + 0.01;
ELSE
	rCommIntervalCounter := 0;
END_IF
IF rCommIntervalCounter >= stSlaveParms.rCommunicationCycleTime THEN
		rCommIntervalCounter := 0;
		nLastOperationStatus := I_ModbusTcpCommunication.mAddToQue(stCommParams:=stModbusTcpData);
		stPimCommunicationData.bLifeBitPLC := NOT stPimCommunicationData.bLifeBitPLC;
END_IF

// Check of communication
IF stSlaveParms.bCommunicationActive THEN
	fbCommunicationTimeout(IN:=TRUE,PT:=T#10S);
	IF stPimCommunicationData.bLifeBitMachine <> bLastLifeBitState THEN
		bLastLifeBitState := stPimCommunicationData.bLifeBitMachine;
		fbCommunicationTimeout(IN:=FALSE);
	END_IF
	IF fbCommunicationTimeout.Q AND iWorkStep < 90 THEN
		mNewEvent(nEventClass:=nPIM_EventClasses.Error,nEvent:=nChiniseMachineErrorCodes.communicationError);
	END_IF
END_IF

// Check of Error
IF stPimCommunicationData.bError AND iWorkStep < 90 AND stSlaveParms.bCommunicationActive THEN
	mNewEvent(nEventClass:=nPIM_EventClasses.Error,nEvent:=stPimCommunicationData.iErrorCode+stSlaveParms.iErrorOffset);
	iWorkStep:=90;
END_IF

//Zabezpieczenie przed błędami w odczycie części do liczenia
IF (stPimCommunicationData.wGoodPartsAmount - iLastPartsRecord) > 5  OR (stPimCommunicationData.wGoodPartsAmount - iLastPartsRecord) < 0 THEN
	iLastPartsRecord := stPimCommunicationData.wGoodPartsAmount;
END_IF
//Parts reset
IF stPimCommunicationData.wGoodPartsAmount = 0  THEN
	iLastPartsRecord := 0;
END_IF


stHMI.nLastOperationStatus 		:= nLastOperationStatus;
stHMI.stModbusTcpData 			:= stModbusTcpData;
stHMI.stPimCommunicationData 	:= stPimCommunicationData;




]]></ST>
      </Implementation>
    </Action>
    <Method Name="FB_init" Id="{262bf5b6-288b-417c-b6cb-adcedd0a4589}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains	: BOOL;
	bInCopyCode 	: BOOL;
	I_Pim			: I_PIM;
	I_ModbusCore	: I_ModbusTcpCore;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[I_PimSystem := I_Pim;
I_ModbusTcpCommunication := I_ModbusCore;
stModbusTcpData.arRegisterReadArray := ADR(arReadArray);
stModbusTcpData.arRegisterWriteArray := ADR(arWriteArray);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mGetParamsData" Id="{b254b609-b7ed-4a1f-973e-a21127e78508}">
      <Declaration><![CDATA[// Metoda TRUE kiedy dane wyjściowe są ok, jeśli nie FALSE (jeśli not bBusy i FALSE to błąd odczytu) 
METHOD mGetParamsData : BOOL
VAR_INPUT
	bTestParams:	BOOL;	// Jeśli TRUE metoda okresla czy ma dostęp do parametrów, jeśli tak zwraca TRUE, jeśli nie FALSE
END_VAR
VAR_OUTPUT
	bBusy:BOOL;		// Maszyna odświeża dane
	pMachineParametersStruct: POINTER TO BYTE;	// Wskaźnik do parametrów pracy maszyny
	uiMachineParametersSize: UINT;				// Rozmiar struktury parametrów pracy maszyny [bajty]
	wActualCRC16SumInMachine: WORD;				// Aktualna suma CRC16 obliczona z parametrów
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF bTestParams THEN
	mGetParamsData := FALSE;
ELSE
	pMachineParametersStruct := 0;
	uiMachineParametersSize := 0;
	bBusy := FALSE;
	mGetParamsData := TRUE;	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="mNewEvent" Id="{a2c8a2c7-cb74-4788-ba9a-91fd36abb8e0}">
      <Declaration><![CDATA[METHOD INTERNAL mNewEvent : BOOL
VAR_INPUT
	nEventClass:nPIM_EventClasses;
	nEvent: INT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nEventClass = nPIM_EventClasses.AlarmAutoConfirm OR nEventClass = nPIM_EventClasses.Message THEN		// Alarm nieblokadowy
	I_PimSystem.mSetNewMachineState(nPIM_MachineStates._0_Initialization);
	iWorkStep := 90;
ELSE
	I_PimSystem.mSetNewMachineState(nPIM_MachineStates._7_ErrorOccurr);

	I_PimSystem.mNewEvent(iEventId := nEvent, nEventType := nEventClass, tMessageTime := T#0S);
	iWorkStep := 90;
END_IF]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="fbChiniseMachine_v2">
      <LineId Id="12" Count="25" />
      <LineId Id="83" Count="1" />
      <LineId Id="38" Count="27" />
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="fbChiniseMachine_v2.ACT_Background">
      <LineId Id="74" Count="0" />
      <LineId Id="1" Count="2" />
      <LineId Id="50" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="51" Count="0" />
      <LineId Id="53" Count="1" />
      <LineId Id="57" Count="4" />
      <LineId Id="55" Count="0" />
      <LineId Id="106" Count="0" />
      <LineId Id="108" Count="0" />
      <LineId Id="110" Count="0" />
      <LineId Id="109" Count="0" />
      <LineId Id="107" Count="0" />
      <LineId Id="62" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="4" Count="0" />
      <LineId Id="9" Count="8" />
      <LineId Id="7" Count="0" />
      <LineId Id="19" Count="0" />
      <LineId Id="23" Count="11" />
      <LineId Id="18" Count="0" />
      <LineId Id="35" Count="1" />
      <LineId Id="38" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="84" Count="1" />
      <LineId Id="41" Count="1" />
      <LineId Id="46" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="111" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="63" Count="10" />
      <LineId Id="39" Count="0" />
      <LineId Id="79" Count="4" />
      <LineId Id="37" Count="0" />
      <LineId Id="87" Count="8" />
      <LineId Id="97" Count="2" />
      <LineId Id="103" Count="1" />
      <LineId Id="100" Count="2" />
      <LineId Id="96" Count="0" />
      <LineId Id="86" Count="0" />
    </LineIds>
    <LineIds Name="fbChiniseMachine_v2.FB_init">
      <LineId Id="3" Count="0" />
      <LineId Id="11" Count="0" />
      <LineId Id="14" Count="2" />
    </LineIds>
    <LineIds Name="fbChiniseMachine_v2.mGetParamsData">
      <LineId Id="44" Count="6" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="fbChiniseMachine_v2.mNewEvent">
      <LineId Id="5" Count="8" />
    </LineIds>
  </POU>
</TcPlcObject>