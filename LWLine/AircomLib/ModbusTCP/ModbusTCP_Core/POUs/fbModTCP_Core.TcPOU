<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.13">
  <POU Name="fbModTCP_Core" Id="{1eebaeb0-68d5-4ffe-85ae-e4bdd94758f4}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK fbModTCP_Core IMPLEMENTS I_ModbusTcpCore
VAR_INPUT
	stTimeStruct : stAircomTimeStruct;																						// Time struct for data ack
END_VAR
VAR_OUTPUT
END_VAR
VAR
	fbModbusTCP 					: FB_MBReadWriteRegs;																	// Main function for ModbusTCP
	arCommQue						: ARRAY[0..GVL_ModbusTCP_Constants.iQueLimit] OF stModTcpQue;							// Que for core
	arModTcpCommandHist				: ARRAY[0..GVL_ModbusTCP_Constants.iCommuniactionHistoryLimit]  OF stModTcpHist;		// Saving of prcesed command
	iWorkStep						: INT;																					// Workstep
	stCommToPerform					: stModTcpQue;																			// Block for process purpose
	iLastQue						: UINT;																					// Que for commands
	iActualQue						: UINT;																					// Actualy performed register of que
	iHistory						: UINT;																					// History record
	rCommunicationTime				: REAL;																					// Time of communication
	fbCommTimeON					: R_TRIG;																				// Start of modbus block - Rise Edge
	fbCommTimeOFF					: F_TRIG;																				// End of modbus block - Falling Edge
	fbErrorDetect					: R_TRIG;																				// Error detected status
	iErrorCalc						: INT;																					// Calculation of errors
	//Visu
	stHMI							: stModTcpCore_HmiData;																	// Data for HMI purpose
	rTimeForStatistic				: REAL;																					// Time variable for statistic calculation - per second
	iLastQueStat					: UINT;																					// Amount of data saved to que
	iActualQueStat					: UINT;																					// Amount od data procesed
	arVisuHist						: ARRAY[0..GVL_ModbusTCP_Constants.iCommuniactionHistoryLimit] OF STRING;				// Command History
	iAmoutOfPerformedCommunications	: DWORD;																				// Sum amount of performed data exchange - per second
	iAmoutOfErrors					: DWORD;																				// Sum amount of errsrs during data exchange - per second
	rTimeforMinuteStatitic			: REAL;																					// Time variable for statistic calculation - per minute
	iLastQueStatMinute				: UINT;																					// Sum amount of performed data exchange - per minute
	iActualQueStatMinute			: UINT;																					// Sum amount of errors during data exchange - per minute
	arErrorHistory					: ARRAY[0..GVL_ModbusTCP_Constants.iCommunicationErrorHistory] OF STRING;				// Data of errors during communicaiotn
	iErrorHistoryIdentifier			: UINT;																					// Calculation of error history
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Rdzeń komuniakcji ModbusTCP
//TO-DO
//Dodać możliwość node - wiele jednoczesnych pracesów
//Dodać możliwosć wymiany inforamcji w Coilach
//Poprawiać ewentualnie wystepujące błędy


ACT_Background();
//Main loop

CASE iWorkStep OF
	0: 		//Inicialization - Step 1
		iWorkStep := 5;

	5: 		//Inicialization - Step 2
		iWorkStep := 10;

	10: 	//Wait for next operaiton
		IF arCommQue[iActualQue].sMachineIndifiner <> '' AND NOT fbModbusTCP.bBusy THEN
			iWorkStep := 15;
		ELSIF NOT fbModbusTCP.bBusy THEN
			IF iActualQue >= GVL_ModbusTCP_Constants.iQueLimit-1 THEN
				iActualQue := 0;
			ELSE
				iActualQue := iActualQue + 1;
			END_IF
		END_IF
	15:		// Check next command
			iWorkStep := 20;
	20:		// Operation prepare - Rewrite for command to perform
		stCommToPerform	:= arCommQue[iActualQue];
		iWorkStep := 25;
	25:		//Clear Que - only one command
		MEMSET(destAddr:=ADR(arCommQue[iActualQue]),fillByte:=0,n:=SIZEOF(stModTcpQue));
		iWorkStep := 30;
		iAmoutOfPerformedCommunications := iAmoutOfPerformedCommunications + 1;
	30:		//Insert command to comm block
		fbModbusTCP.sIPAddr 			:=	stCommToPerform.sIpAdress;
		fbModbusTCP.nUnitID				:=	stCommToPerform.iUnitId;
		fbModbusTCP.nTCPPort			:=	stCommToPerform.iPort;
		fbModbusTCP.nMBReadAddr 		:= 	stCommToPerform.iRegisterReadStartAdress;
		fbModbusTCP.nMBWriteAddr 		:= 	stCommToPerform.iRegisterWriteStartAdress;
			// Dodać error w przypadku ilości rejestrów większych od iWriteRegisterLimit/2
		fbModbusTCP.nReadQuantity 		:=	stCommToPerform.wRegistersReadQuantity;
		fbModbusTCP.nWriteQuantity		:=	stCommToPerform.wRegistersWriteQuantity;
			//Source - Data tobe written in slave | Destination - Data to be read form slave
		fbModbusTCP.cbSrcLength 		:= SIZEOF(stCommToPerform.arRegisterWriteArray^);
		fbModbusTCP.pSrcAddr 			:= stCommToPerform.arRegisterWriteArray;
		fbModbusTCP.cbDestLength 		:= SIZEOF(stCommToPerform.arRegisterReadArray^);
		fbModbusTCP.pDestAddr 			:= stCommToPerform.arRegisterReadArray;
			//Check if history buffer is full - if yes start form 0
		IF iHistory >= GVL_ModbusTCP_Constants.iCommuniactionHistoryLimit THEN
			iHistory := 0;
		END_IF
		arModTcpCommandHist[iHistory].sIpAdress 			:= 	stCommToPerform.sIpAdress;
		arModTcpCommandHist[iHistory].iUnitId 				:=	stCommToPerform.iUnitId;
		arModTcpCommandHist[iHistory].iPort 				:=	stCommToPerform.iPort;
		arModTcpCommandHist[iHistory].sMachineIndifiner 	:= 	stCommToPerform.sMachineIndifiner;
		arModTcpCommandHist[iHistory].sTimeString 			:= 	stTimeStruct.sTimeString;
		arVisuHist[iHistory] := CONCAT(STR1:=arModTcpCommandHist[iHistory].sIpAdress ,STR2:=' | ');
		arVisuHist[iHistory] := CONCAT(STR1:=arVisuHist[iHistory] ,STR2:=arModTcpCommandHist[iHistory].sMachineIndifiner);
		arVisuHist[iHistory] := CONCAT(STR1:=arVisuHist[iHistory] ,STR2:=' | ');
		arVisuHist[iHistory] := CONCAT(STR1:=arVisuHist[iHistory] ,STR2:= arModTcpCommandHist[iHistory].sTimeString);
		arVisuHist[iHistory] := CONCAT(STR1:=arVisuHist[iHistory] ,STR2:=' | ');
		
		iWorkStep := 40;
	40:		// Data exchange start
		fbModbusTCP.bExecute := TRUE;
		IF fbModbusTCP.bBusy THEN
			fbModbusTCP.bExecute := FALSE;
			iWorkStep := 50;
		END_IF
	50: 	//Wait for not busy
		IF NOT fbModbusTCP.bBusy THEN
			iWorkStep := 10;
		END_IF

END_CASE]]></ST>
    </Implementation>
    <Action Name="ACT_Background" Id="{3293cfc1-0622-4dd3-8ae2-5d0eb1a0ab74}">
      <Implementation>
        <ST><![CDATA[// Main function
fbModbusTCP();
//Error counting
fbErrorDetect(CLK:= fbModbusTCP.bError);
IF fbErrorDetect.Q THEN
	iErrorCalc := iErrorCalc + 1;
	iAmoutOfErrors := iAmoutOfErrors + 1;
	arErrorHistory[iErrorHistoryIdentifier] := CONCAT(STR1:= stCommToPerform.sMachineIndifiner,STR2:=' | ');
	arErrorHistory[iErrorHistoryIdentifier] := CONCAT(STR1:= arErrorHistory[iErrorHistoryIdentifier],STR2:=stCommToPerform.sIpAdress);
	arErrorHistory[iErrorHistoryIdentifier] := CONCAT(STR1:= arErrorHistory[iErrorHistoryIdentifier],STR2:=' | ');
	arErrorHistory[iErrorHistoryIdentifier] := CONCAT(STR1:= arErrorHistory[iErrorHistoryIdentifier],STR2:=LREAL_TO_FMTSTR(in:=rCommunicationTime,iPrecision:=3,bRound:= FALSE));
	arErrorHistory[iErrorHistoryIdentifier] := CONCAT(STR1:= arErrorHistory[iErrorHistoryIdentifier],STR2:=' | ');
	arErrorHistory[iErrorHistoryIdentifier] := CONCAT(STR1:= arErrorHistory[iErrorHistoryIdentifier],STR2:=UDINT_TO_STRING(fbModbusTCP.nErrId));
	iErrorHistoryIdentifier := iErrorHistoryIdentifier + 1;
END_IF
// Clear amount of errors
IF fbModbusTCP.cbRead <> 0 THEN
	iErrorCalc := 0;
END_IF

//Communication statistic
fbCommTimeON(CLK:= fbModbusTCP.bBusy);
fbCommTimeOFF(CLK:= fbModbusTCP.bBusy);
IF fbCommTimeON.Q THEN
	rCommunicationTime := 0;
END_IF
IF fbModbusTCP.bBusy THEN
	rCommunicationTime := rCommunicationTime + 0.01;
END_IF
IF fbCommTimeOFF.Q THEN
	arModTcpCommandHist[iHistory].rCommandTime := rCommunicationTime;
	arVisuHist[iHistory] := CONCAT(STR1:=arVisuHist[iHistory] ,STR2:=LREAL_TO_FMTSTR(in:=rCommunicationTime,iPrecision:=3,bRound:= FALSE));
	arVisuHist[iHistory] := CONCAT(STR1:=arVisuHist[iHistory] ,STR2:=' | ');
	arModTcpCommandHist[iHistory].nErrorId := fbModbusTCP.nErrId;
	arVisuHist[iHistory] := CONCAT(STR1:=arVisuHist[iHistory] ,STR2:=UDINT_TO_STRING(arModTcpCommandHist[iHistory].nErrorId));
	iHistory := iHistory + 1;
	iActualQueStat := iActualQueStat + 1;
END_IF

//HMI

stHMI.arVisuHist 						:= arVisuHist;
stHMI.arErrorHistory 					:= arErrorHistory;
stHMI.iActualQue 						:= iActualQue;
stHMI.iAmoutOfErrors 					:= iAmoutOfErrors;
stHMI.iAmoutOfPerformedCommunications 	:= iAmoutOfPerformedCommunications;
stHMI.iLastQue 							:= iLastQue;
stHMI.iMessagesPerMinute 				:= iActualQueStatMinute;
stHMI.iPullsPerrMinute					:= iLastQueStatMinute;

IF stHMI.bClearStatistic THEN
	iAmoutOfPerformedCommunications := 0;
	iAmoutOfErrors := 0;
	iActualQueStatMinute := 0;
	iLastQueStatMinute := 0;
	iErrorHistoryIdentifier := 0;
	iHistory := 0;
	stHMI.bClearStatistic := FALSE;
	MEMSET(destAddr:=ADR(arErrorHistory),fillByte:=0,n:= SIZEOF(arErrorHistory));
	MEMSET(destAddr:=ADR(arVisuHist),fillByte:=0,n:= SIZEOF(arVisuHist));
END_IF

IF rTimeForStatistic >= GVL_ModbusTCP_Constants.rTimeForSecondStatistic THEN
	stHMI.iMessagesPerSecond := iActualQueStat;
	stHMI.iPullsPerSecond	:= iLastQueStat;
	iActualQueStatMinute := iActualQueStatMinute + iActualQueStat;
	iLastQueStatMinute	:= iLastQueStatMinute + iLastQueStat;
	iLastQueStat 	:= 0;
	iActualQueStat	:= 0;
	rTimeForStatistic := 0;
END_IF

IF rTimeforMinuteStatitic >= GVL_ModbusTCP_Constants.rTimeForMinuteStatistic THEN
	iActualQueStatMinute := 0;
	iLastQueStatMinute := 0;
	rTimeforMinuteStatitic := 0;
END_IF

rTimeForStatistic := rTimeForStatistic + 0.01;
rTimeforMinuteStatitic := rTimeforMinuteStatitic + 0.01;

fbModbusTCP.tTimeout := GVL_ModbusTCP_Constants.tModbusCommunicationTimeOut;
	]]></ST>
      </Implementation>
    </Action>
    <Method Name="mAddToQue" Id="{6fcee0ac-971a-4c86-9aba-3116f2e46b99}">
      <Declaration><![CDATA[METHOD mAddToQue : nModbusTCP_CommandStatus;
VAR_INPUT
	stCommParams	: stModTcpQue;
END_VAR
VAR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF stCommParams.sIpAdress <> '' AND stCommParams.iPort <> 0 AND stCommParams.sMachineIndifiner <> '' 
AND stCommParams.arRegisterReadArray <> 0 AND stCommParams.arRegisterWriteArray <> 0 AND stCommParams.wRegistersReadQuantity <> 0 AND stCommParams.wRegistersWriteQuantity <> 0
AND stCommParams.wRegistersReadQuantity <= 2*SIZEOF(stCommParams.arRegisterReadArray^) AND stCommParams.wRegistersWriteQuantity <= 2*SIZEOF(stCommParams.arRegisterWriteArray^) THEN
	//IF arCommQue[iLastQue].sMachineIndifiner = stCommParams.sMachineIndifiner THEN
		//mAddToQue := nModbusTCP_CommandStatus.nCommandAlreadyinQue_03;
	//ELSE
		IF iLastQue >= GVL_ModbusTCP_Constants.iQueLimit THEN
			iLastQue := 0;
		END_IF
		IF arCommQue[iLastQue].sMachineIndifiner <> '' THEN
			mAddToQue := nModbusTCP_CommandStatus.nRecordAllreadyInUse_04;
			iLastQue := iLastQue + 1;
			iLastQueStat := iLastQueStat + 1;
		ELSE
			arCommQue[iLastQue] := stCommParams;
			mAddToQue := nModbusTCP_CommandStatus.nCommandPerformed_01;
			iLastQue := iLastQue + 1;
			iLastQueStat := iLastQueStat + 1;
		END_IF
	//END_IF
ELSE
	mAddToQue := nModbusTCP_CommandStatus.nCommandWrongParams_02;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Property Name="pError" Id="{362ccfd9-47cc-416e-ab04-599a1a60cbea}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY pError : BOOL]]></Declaration>
      <Get Name="Get" Id="{fbab18ed-4e0e-4244-9bec-484473e8833a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[pError := iErrorCalc >= GVL_ModbusTCP_Constants.iErrorLimit;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <LineIds Name="fbModTCP_Core">
      <LineId Id="178" Count="1" />
      <LineId Id="182" Count="1" />
      <LineId Id="185" Count="0" />
      <LineId Id="180" Count="1" />
      <LineId Id="153" Count="0" />
      <LineId Id="108" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="12" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="29" Count="1" />
      <LineId Id="28" Count="0" />
      <LineId Id="19" Count="3" />
      <LineId Id="131" Count="0" />
      <LineId Id="156" Count="1" />
      <LineId Id="160" Count="0" />
      <LineId Id="162" Count="1" />
      <LineId Id="161" Count="0" />
      <LineId Id="132" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="130" Count="0" />
      <LineId Id="24" Count="0" />
      <LineId Id="45" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="33" Count="0" />
      <LineId Id="52" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="165" Count="0" />
      <LineId Id="53" Count="0" />
      <LineId Id="57" Count="1" />
      <LineId Id="55" Count="0" />
      <LineId Id="78" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="86" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="83" Count="0" />
      <LineId Id="99" Count="0" />
      <LineId Id="71" Count="2" />
      <LineId Id="56" Count="0" />
      <LineId Id="65" Count="3" />
      <LineId Id="168" Count="0" />
      <LineId Id="176" Count="1" />
      <LineId Id="169" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="175" Count="0" />
      <LineId Id="170" Count="0" />
      <LineId Id="34" Count="2" />
      <LineId Id="128" Count="0" />
      <LineId Id="60" Count="1" />
      <LineId Id="40" Count="0" />
      <LineId Id="62" Count="1" />
      <LineId Id="37" Count="0" />
      <LineId Id="18" Count="0" />
      <LineId Id="17" Count="0" />
    </LineIds>
    <LineIds Name="fbModTCP_Core.ACT_Background">
      <LineId Id="2" Count="0" />
      <LineId Id="15" Count="0" />
      <LineId Id="104" Count="0" />
      <LineId Id="3" Count="2" />
      <LineId Id="33" Count="0" />
      <LineId Id="90" Count="1" />
      <LineId Id="93" Count="1" />
      <LineId Id="106" Count="1" />
      <LineId Id="92" Count="0" />
      <LineId Id="6" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="7" Count="1" />
      <LineId Id="1" Count="0" />
      <LineId Id="17" Count="1" />
      <LineId Id="20" Count="9" />
      <LineId Id="34" Count="1" />
      <LineId Id="30" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="31" Count="0" />
      <LineId Id="68" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="39" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="40" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="42" Count="3" />
      <LineId Id="99" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="48" Count="1" />
      <LineId Id="52" Count="0" />
      <LineId Id="77" Count="1" />
      <LineId Id="109" Count="1" />
      <LineId Id="51" Count="0" />
      <LineId Id="101" Count="1" />
      <LineId Id="50" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="57" Count="0" />
      <LineId Id="63" Count="1" />
      <LineId Id="75" Count="1" />
      <LineId Id="66" Count="1" />
      <LineId Id="65" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="53" Count="0" />
      <LineId Id="79" Count="0" />
      <LineId Id="81" Count="0" />
      <LineId Id="84" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="89" Count="0" />
      <LineId Id="88" Count="0" />
      <LineId Id="85" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="87" Count="0" />
      <LineId Id="61" Count="0" />
    </LineIds>
    <LineIds Name="fbModTCP_Core.mAddToQue">
      <LineId Id="76" Count="2" />
      <LineId Id="80" Count="5" />
      <LineId Id="94" Count="1" />
      <LineId Id="101" Count="0" />
      <LineId Id="107" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="99" Count="1" />
      <LineId Id="98" Count="0" />
      <LineId Id="108" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="89" Count="4" />
      <LineId Id="21" Count="0" />
    </LineIds>
    <LineIds Name="fbModTCP_Core.pError.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>