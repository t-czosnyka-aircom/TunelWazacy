<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="fbRecMan" Id="{502b21c2-6b3a-4005-9f10-0c6aee73cadd}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK fbRecMan
VAR CONSTANT
	iMaxRecipeNumber:INT:=40;		// If you change this value, you must also update astRecipeList array size (same value)
	iMaxStructureSize:INT:= 1024;
END_VAR
VAR_INPUT
	sRecipesDirectory:STRING;
	pPLC_Struct:POINTER TO BYTE;
	iPLC_StructSize:INT;
	pTMP_PLC_Struct:POINTER TO BYTE;				// Struktura pomocnicza - konieczna do deklaracji
	bTextFormat:BOOL:= FALSE;
END_VAR
VAR_OUTPUT
	bError:BOOL;
	nErrorCode:enRecMan_ErrorList;
END_VAR
VAR
	fbFileOpen:FB_FileOpen;
	fbFileRead:FB_FileRead;
	fbFileWrite:FB_FileWrite;
	fbFileClose:FB_FileClose;
	fbFileDelete:FB_FileDelete;
	fbReloadRecipes:FB_EnumFindFileEntry;
	
	// HMI variables
	sRecipeName:STRING;
	bReloadRecipes:BOOL;
	bWriteRecipe:BOOL;
	bReadRecipe:BOOL;
	bCopyTMP_2_PLC:BOOL;
	bCopyPLC_2_TMP:BOOL;
	
	
	iStructSize:INT;
	bWritingRecipe: BOOL;
	iStep: INT;
	fbTON_StepTimeout: TON;
	hFiileHandler: UINT;
	uiErrorID: UDINT;
	bRecipeSave_OK: BOOL;
	bReadingRecipe: BOOL;
	bRecipeRead_OK: BOOL;
	bPointerValid: BOOL;
	bRefreshRecipeList: BOOL;
	bRecipeList_Reloaded: BOOL;
	bFirstEntry: BOOL;
	bAbort: BOOL;
	astRecipeList:ARRAY [1..40] OF stRecMan_ListEntry;
	iNbOfFoundRecipes: INT;
	bRefreshingRecipeList: BOOL;
	bResetInternal: BOOL;
	iTableSelIndex:INT;
	bTableRowSelected:BOOL;
	wCRCsum: WORD;
	bSizeNotEqual: BOOL;
	wCRCsumReaded: WORD;
	bFileOpen: BOOL;
	bCloseFileAfterError: BOOL;
	nErrorCodeMemory:INT;
	iTableSelIndexMemory: INT;
	bSavePLCStruct: BOOL;
	bDeleteRecipe: BOOL;
	bDeletingRecipe: BOOL;
	bRecipeDeleted_OK: BOOL;
	bDeleteConfirmed: BOOL;
	bCopyTMP_2_PLC_Confirmed: BOOL;
	fbRTRIG_ReloadList: R_TRIG;
	fbTON_OKSigReset: TON;
	fbTON_DeleteConfirmWindowReset: TON;
	fbTON_Copy2PLCConfirmWindowReset: TON;
END_VAR

]]></Declaration>
    <Implementation>
      <ST><![CDATA[(*
******************************************* Recipe Manager *******************************************

Jako wejście podajemy adres struktury w króre są przechowywane dane (struktury docelowej pPLC_Struct oraz tymczasowej używanej jako bufor panmięci pTMP_PLC_Struct). 

Format zapisu struktury - Dane są zapisywane jako postać binarna - struktura nie powinna zmieniać swojej postaci!. Jeśli koniecznie należy dodać zmienną do struktury
należy dodawać na końcu struktury. Wtedy gdy zapisana receptura nie ma wystarczającej ilości danych, struktura w PLC uzupełniana jest tylko do rozmiaru zawartego w recepturze.
Każda reseptura jest zapisana w poniższym formacie: 
	- pierwsze 2 bajty to rozmiar danych w strukturze (dane są umiejscowione zgodnie z formatem struktury od 3-go bajtu
	- n bajtów danych struktury
	- ostatnie dwa bajty to suma CRC16 obliczana z danych struktury (PRZED ZAPISEM DANYCH STRUKTURY NALEŻY WYZEROWAĆ PAMIĘĆ STRUKTURY aby nieużywane bajty nie wpłyneły na sumę CRC!!!)
	
Współpraca z PIM:
Podczas zalogowania użytkownika sterownik automatycznie odpytuje bazę danych o sumę CRC aktualnej wersji parametrów (trzeba też odczytać parametry urządzenia np zgrzewarki), 
baza danych (DB) zwraca zatwierdzoną aktualną sumę CRC, następuje porównanie sumy CRC z DB oraz z urządzenia. W razie zgodności urządzenie jest dopuszczone do pracy, inaczej jest blokowane

Konfiguracja - w przypadku gdy w DB nie ma parametrów lub parametry w maszynie są nieaktualne trzeba nadpisać aktywny zestaw parametrów w DB.
Istnieje możliwość zapisu aktualnych parametrów do DB, w tym celu system PIM ustawia odpowiednią zmienną, po ustawieniu sterownik PLC pobiera dane z maszyny oraz wysyła do DB wraz z nową sumą CRC

*)

bPointerValid := pTMP_PLC_Struct > 0 AND pPLC_Struct > 0 AND iPLC_StructSize > 0;

IF (bWriteRecipe OR bWritingRecipe) AND NOT bReadingRecipe AND NOT bRefreshingRecipeList AND bPointerValid AND LEN(sRecipeName) > 2 THEN
	ACT_WriteRecipe();
	bWriteRecipe := FALSE;
	bRecipeList_Reloaded := FALSE;
END_IF

IF (bReadRecipe OR bReadingRecipe) AND NOT bWritingRecipe AND NOT bRefreshingRecipeList AND bPointerValid AND bRecipeList_Reloaded AND bTableRowSelected THEN
	ACT_ReadRecipe();
	bReadRecipe := FALSE;
END_IF

IF (bReloadRecipes OR bRefreshingRecipeList) AND NOT bWritingRecipe AND NOT bReadingRecipe THEN
	ACT_RefreshRecipeList();
	bReloadRecipes := FALSE;
END_IF

IF ((bDeleteRecipe AND bDeleteConfirmed) OR bDeletingRecipe) AND NOT bReadingRecipe AND NOT bRefreshingRecipeList AND NOT bWritingRecipe AND bTableRowSelected THEN
	ACT_DeleteRecipe();
	bDeleteConfirmed := bDeleteRecipe := FALSE;
	bRecipeList_Reloaded := FALSE;
END_IF
fbTON_DeleteConfirmWindowReset(IN:= bDeleteRecipe, PT:= T#15S);
bDeleteRecipe R= fbTON_DeleteConfirmWindowReset.Q;

IF (bWriteRecipe AND NOT bWritingRecipe) OR (bReadRecipe AND NOT bReadingRecipe) OR (bReloadRecipes AND NOT bRefreshingRecipeList) OR (bDeleteConfirmed AND NOT bDeletingRecipe) THEN
	nErrorCode := enRecMan_ErrorList.CommandStartProgramError;
	bWriteRecipe := bReadRecipe := bReloadRecipes := bDeleteRecipe := bDeleteConfirmed := FALSE;
END_IF

fbRTRIG_ReloadList(CLK:= (bRecipeDeleted_OK AND NOT bDeletingRecipe) OR (bRecipeSave_OK AND NOT bWritingRecipe));
IF fbRTRIG_ReloadList.Q THEN
	bReloadRecipes:= TRUE;
END_IF

fbTON_OKSigReset(IN:= bRecipeDeleted_OK OR bRecipeRead_OK OR bRecipeSave_OK, PT:= T#5S);
IF fbTON_OKSigReset.Q THEN
	bRecipeDeleted_OK := bRecipeRead_OK := bRecipeSave_OK := FALSE;
END_IF

IF bResetInternal THEN
	iStep := 0;	
	IF bFileOpen THEN
		fbFileClose(bExecute:= FALSE);
		fbFileClose(hFile:= hFiileHandler, 
			bExecute:= TRUE, 
			tTimeout:= T#1S,);
		IF NOT fbFileClose.bBusy THEN
			IF fbFileClose.bError THEN
				uiErrorID:= fbFileClose.nErrId;
				nErrorCodeMemory := enRecMan_ErrorList.NoError;
				nErrorCode := enRecMan_ErrorList.FileCloseError;
				bResetInternal := FALSE;
			ELSE
				bFileOpen := FALSE;
				bResetInternal := FALSE;
				nErrorCodeMemory := nErrorCode := enRecMan_ErrorList.NoError;
				bError := FALSE;
			END_IF
			fbFileClose(bExecute:= FALSE);
		END_IF
	ELSE
		bResetInternal := FALSE;
		nErrorCodeMemory := nErrorCode := enRecMan_ErrorList.NoError;
		bError := FALSE;
	END_IF
END_IF

IF nErrorCode <> enRecMan_ErrorList.NoError AND nErrorCodeMemory <> nErrorCode THEN
	bError := TRUE;
END_IF
nErrorCodeMemory := nErrorCode;

// Update file name
IF iTableSelIndex <> iTableSelIndexMemory AND iTableSelIndex > 0 AND iTableSelIndex <= iMaxRecipeNumber THEN
	sRecipeName := astRecipeList[iTableSelIndex].sFileName;
	iTableSelIndexMemory := iTableSelIndex;
END_IF

IF bCopyPLC_2_TMP AND NOT bWritingRecipe AND NOT bReadingRecipe AND NOT bRefreshingRecipeList THEN
	MEMCPY(srcAddr := pPLC_Struct, destAddr := pTMP_PLC_Struct, n := INT_TO_UDINT(iPLC_StructSize));
	bCopyPLC_2_TMP := FALSE;
END_IF

IF (bCopyTMP_2_PLC AND bCopyTMP_2_PLC_Confirmed) AND NOT bWritingRecipe AND NOT bReadingRecipe AND NOT bRefreshingRecipeList THEN
	MEMCPY(srcAddr := pTMP_PLC_Struct, destAddr := pPLC_Struct, n := INT_TO_UDINT(iPLC_StructSize));
	bCopyTMP_2_PLC := bCopyTMP_2_PLC_Confirmed := FALSE;
END_IF
fbTON_Copy2PLCConfirmWindowReset(IN:= bCopyTMP_2_PLC, PT:= T#15S);
bCopyTMP_2_PLC R= fbTON_Copy2PLCConfirmWindowReset.Q;]]></ST>
    </Implementation>
    <Action Name="ACT_DeleteRecipe" Id="{3340f6b1-68a6-40f9-9079-146dd3518059}">
      <Implementation>
        <ST><![CDATA[CASE iStep OF
	0:	// Default Step
		bDeletingRecipe := TRUE;
		fbFileDelete(bExecute := FALSE);
		fbTON_StepTimeout(IN:= FALSE);
		iStep := 10;
		
	10: 	// Open file for read
		fbFileDelete(
			sPathName:= CONCAT(STR1:= sRecipesDirectory, STR2 := CONCAT(STR1:= sRecipeName ,STR2:= '.recipe')), 
			ePath:= PATH_GENERIC, 
			bExecute:= TRUE, 
			tTimeout:= T#1S, 
			bBusy=> , 
			bError=> , 
			nErrId=> );
		
		IF NOT fbFileDelete.bBusy THEN
			IF fbFileDelete.bError THEN
				iStep:= 99;
				uiErrorID:= fbFileDelete.nErrId;
				nErrorCode := enRecMan_ErrorList.FileDeleteError;
			ELSE
				iStep:= 50;
			END_IF
			fbFileDelete(bExecute:= FALSE); 
		END_IF
		
	50:		// Save success
		bRecipeDeleted_OK:= TRUE;
		iStep:= 100;
		
	99:
		bRecipeDeleted_OK:= FALSE;
		iStep:= 100;
		
	100:
		bDeletingRecipe := FALSE;
		fbTON_StepTimeout(IN:= FALSE);
		iStep:= 0;
END_CASE

fbTON_StepTimeout(IN:= TRUE, PT:= T#3S);
IF fbTON_StepTimeout.Q THEN
	fbTON_StepTimeout(IN:= FALSE);
	nErrorCode := enRecMan_ErrorList.DeleteRecipeTimeout;
	iStep:= 0;
	bDeletingRecipe := FALSE;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="ACT_ReadRecipe" Id="{8c2fcbde-fe37-4f29-8771-42de0a057136}">
      <Implementation>
        <ST><![CDATA[CASE iStep OF
	0:	// Default Step
		bRecipeRead_OK:= FALSE;
		bReadingRecipe := TRUE;
		bCloseFileAfterError := FALSE;
		fbFileOpen(bExecute := FALSE);
		fbFileRead(bExecute := FALSE);
		fbFileClose(bExecute := FALSE);
		fbTON_StepTimeout(IN:= FALSE);
		bSizeNotEqual := FALSE;
		iStep := 10;
		
	10: 	// Open file for read
		fbFileOpen(
			sPathName:= CONCAT(STR1:= sRecipesDirectory, STR2 := CONCAT(STR1:= sRecipeName ,STR2:= '.recipe')), 
			nMode:= FOPEN_MODEREAD OR SEL(bTextFormat,FOPEN_MODEBINARY,FOPEN_MODETEXT), 
			ePath:= PATH_GENERIC, 
			bExecute:= TRUE, 
			tTimeout:= T#1S, 
			hFile=>hFiileHandler );
		
		IF NOT fbFileOpen.bBusy THEN
			IF fbFileOpen.bError THEN
				iStep:= 99;
				bFileOpen:=FALSE;
				uiErrorID:= fbFileOpen.nErrId;
				nErrorCode := enRecMan_ErrorList.FileOpenError;
			ELSE
				iStep:= 20;
				bFileOpen:=TRUE;
			END_IF
			fbFileOpen(bExecute:= FALSE); 
		END_IF
	
	20:		// Read Header
		fbFileRead(
			hFile:= hFiileHandler, 
			pReadBuff:= ADR(iStructSize), 
			cbReadLen:= SIZEOF(iStructSize), 
			bExecute:= TRUE, 
			tTimeout:= T#1S);
			
		IF NOT fbFileRead.bBusy THEN
			IF fbFileRead.cbRead <> fbFileRead.cbReadLen THEN
				nErrorCode := enRecMan_ErrorList.ReadSizeError;
				iStep:= 99;
			ELSE
				IF fbFileRead.bError THEN
					iStep:= 99;
					uiErrorID:= fbFileRead.nErrId;
					nErrorCode := enRecMan_ErrorList.ReadRecipeError;
				ELSE
					MEMSET(destAddr := pTMP_PLC_Struct, n := INT_TO_UDINT(iPLC_StructSize), fillByte := 0);		// clear memory before write data (necessary for CRC sum consistent)
					iStep:= 30;
				END_IF
			END_IF		
			fbFileRead(bExecute:= FALSE); 
		END_IF
		
	30:		// Read Data
		IF iStructSize = iPLC_StructSize THEN		// exact size data in recipe and PLC or not enought data in recipe
			fbFileRead.cbReadLen:= INT_TO_UINT(iStructSize);
			bSizeNotEqual := FALSE;
		ELSIF iStructSize < iPLC_StructSize THEN
			fbFileRead.cbReadLen:= INT_TO_UINT(iStructSize);
			bSizeNotEqual := TRUE;
		ELSE 	// to much data in recipe	 
			fbFileRead.cbReadLen:= INT_TO_UINT(iPLC_StructSize);
			bSizeNotEqual := TRUE;
		END_IF
		fbFileRead(
			hFile:= hFiileHandler, 
			pReadBuff:= pTMP_PLC_Struct, 
			bExecute:= TRUE, 
			tTimeout:= T#1S);	
		IF NOT fbFileRead.bBusy THEN
			IF fbFileRead.cbRead <> fbFileRead.cbReadLen THEN
				iStep:= 99;
			ELSE
				IF fbFileRead.bError THEN
					iStep:= 99;
					uiErrorID:= fbFileRead.nErrId;
				ELSE
					iStep:= 35;
					wCRCsum:= F_DATA_TO_CRC16_CCITT(pData:= fbFileRead.pReadBuff, cbData := fbFileRead.cbReadLen, crc := 16#0000);
				END_IF
			END_IF
			fbFileRead(bExecute:= FALSE);		
		END_IF	
	
	35:		// Read and check CRC16sum	
		IF NOT bSizeNotEqual THEN
			fbFileRead(
				hFile:= hFiileHandler, 
				pReadBuff:= ADR(wCRCsumReaded), 
				cbReadLen := SIZEOF(wCRCsumReaded),
				bExecute:= TRUE, 
				tTimeout:= T#1S);	
			IF NOT fbFileRead.bBusy THEN
				IF fbFileRead.cbRead <> fbFileRead.cbReadLen THEN
					iStep:= 99;
					nErrorCode:= enRecMan_ErrorList.ReadSizeError;
				ELSE
					IF fbFileRead.bError THEN
						iStep:= 99;
						uiErrorID:= fbFileRead.nErrId;
					ELSE
						IF wCRCsumReaded = wCRCsum THEN
							iStep:= 40;
						ELSE
							iStep:= 99;
							nErrorCode:= enRecMan_ErrorList.BadCRC;
						END_IF
					END_IF
				END_IF
				fbFileRead(bExecute:= FALSE);		
			END_IF	
		ELSE
			iStep:= 40;
		END_IF
	
	40:		// Close file
			fbFileClose(
			hFile:= hFiileHandler, 
			bExecute:= TRUE, 
			tTimeout:= T#1S);
		IF NOT fbFileClose.bBusy THEN
			IF fbFileClose.bError THEN
				iStep:= 99;
				uiErrorID:= fbFileClose.nErrId;
				nErrorCode := enRecMan_ErrorList.FileCloseError;
			ELSE
				bFileOpen := FALSE;
				iStep:= 50;
			END_IF
			IF bCloseFileAfterError THEN
				bFileOpen R= NOT fbFileClose.bError;
				iStep:= 100;
				bCloseFileAfterError := FALSE;
			END_IF
			fbFileClose(bExecute:= FALSE);
		END_IF
		
	50:		// Save success
		bRecipeRead_OK:= TRUE;
		iStep:= 100;
		
	99:
		bRecipeRead_OK:= FALSE;
		IF bFileOpen THEN
			bCloseFileAfterError := TRUE;
			fbFileClose(bExecute:= TRUE); 
			iStep := 40;
		ELSE
			bCloseFileAfterError := FALSE;
			iStep:= 100;
		END_IF
		
	100:
		bReadingRecipe := FALSE;
		fbTON_StepTimeout(IN:= FALSE);
		fbFileOpen(bExecute := FALSE);
		fbFileRead(bExecute := FALSE);
		fbFileClose(bExecute := FALSE);
		iStep:= 0;
END_CASE

fbTON_StepTimeout(IN:= TRUE, PT:= T#3S);
IF fbTON_StepTimeout.Q THEN
	fbTON_StepTimeout(IN:= FALSE);
	nErrorCode := enRecMan_ErrorList.ReadRecipeTimeout;
	iStep:= 0;
	bReadingRecipe := FALSE;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="ACT_RefreshRecipeList" Id="{b8b14d3f-4d30-4ba9-bc53-9a147ee434a9}">
      <Implementation>
        <ST><![CDATA[
CASE iStep OF
	0:	// Default Step
		bRecipeList_Reloaded:= FALSE;
		bRefreshingRecipeList := TRUE;
		fbReloadRecipes(bExecute := FALSE);
		iStep := 10;
		iNbOfFoundRecipes := 0;
		MEMSET(destAddr := ADR(astRecipeList),n := SIZEOF(astRecipeList),fillByte := 0);
		fbReloadRecipes(
			eCmd:= eEnumCmd_First,
			sPathName:= CONCAT(STR1:= sRecipesDirectory, STR2:= '*.recipe'), 
			bExecute:= FALSE, 
			tTimeout:= T#2S, 
			bBusy=> , 
			bError=> , 
			nErrID=> , 
			bEOE=> , 
			stFindFile=> );
		fbTON_StepTimeout(IN:= FALSE);

	10: 	
		IF bAbort THEN
			bAbort := FALSE;
			fbReloadRecipes.eCmd := eEnumCmd_Abort;
			iStep := 30;
		ELSE
			iStep := 20;
		END_IF
		fbReloadRecipes(bExecute := FALSE);
		fbReloadRecipes(bExecute := TRUE);

	20:
		fbReloadRecipes(bExecute := FALSE);
		IF NOT fbReloadRecipes.bBusy THEN
			IF NOT fbReloadRecipes.bError THEN
				IF NOT fbReloadRecipes.bEOE THEN	
					IF iNbOfFoundRecipes <= iMaxRecipeNumber THEN	// Save entry and read next
						fbReloadRecipes.eCmd:= eEnumCmd_Next;
						iNbOfFoundRecipes := iNbOfFoundRecipes + 1;
						astRecipeList[iNbOfFoundRecipes].sFileName :=  LEFT(STR :=fbReloadRecipes.stFindFile.sFileName,SIZE := LEN(fbReloadRecipes.stFindFile.sFileName)-7);
						astRecipeList[iNbOfFoundRecipes].dtCreationTime := FILETIME_TO_DT(fbReloadRecipes.stFindFile.creationTime);						
					ELSE	// List  full
						bAbort := TRUE;
					END_IF
					iStep := 10;
				ELSE	// No more entries
					iStep := 30;
				END_IF
			ELSE	// log error
				uiErrorID := fbReloadRecipes.nErrID;
				iStep := 99;
			END_IF
		END_IF
			
	30:	// Save success
		bRecipeList_Reloaded:= TRUE;
		bRefreshingRecipeList := FALSE;
		iStep:= 0;
		
	99:
		bRecipeList_Reloaded:= FALSE;
		bRefreshingRecipeList := FALSE;
		iStep:= 0;
		
END_CASE
fbTON_StepTimeout(IN:= TRUE, PT:= T#5S);
IF fbTON_StepTimeout.Q THEN
	iStep:= 99;
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="ACT_WriteRecipe" Id="{0f8d76bb-f9a2-4d6b-9cf5-30a9370f605c}">
      <Implementation>
        <ST><![CDATA[CASE iStep OF
	0:	// Default Step
		bRecipeSave_OK:= FALSE;
		bWritingRecipe := TRUE;
		fbTON_StepTimeout(IN:= FALSE);
		fbFileOpen(bExecute := FALSE);
		fbFileWrite(bExecute := FALSE);
		fbFileClose(bExecute := FALSE);
		IF iPLC_StructSize < iMaxStructureSize THEN
			iStructSize := iPLC_StructSize;
			iStep := 10;
		ELSE
			iStep := 99;
			nErrorCode :=enRecMan_ErrorList.StructToBig;
		END_IF
		
	10: 	// Open file for write
		fbFileOpen(
			sPathName:= CONCAT(STR1:= sRecipesDirectory, STR2 := CONCAT(STR1:= sRecipeName,STR2:= '.recipe')), 
			nMode:= FOPEN_MODEWRITE OR SEL(bTextFormat,FOPEN_MODEBINARY,FOPEN_MODETEXT), 
			ePath:= PATH_GENERIC, 
			bExecute:= TRUE, 
			tTimeout:= T#1S, 
			hFile=>hFiileHandler );
		
		IF NOT fbFileOpen.bBusy THEN
			IF fbFileOpen.bError THEN
				iStep:= 99;
				uiErrorID:= fbFileOpen.nErrId;
				nErrorCode := enRecMan_ErrorList.FileOpenError;
			ELSE
				iStep:= 20;
			END_IF
			fbFileOpen(bExecute:= FALSE);
		END_IF
		
	20:		// Save Header
		fbFileWrite(
			hFile:= hFiileHandler, 
			pWriteBuff:= ADR(iStructSize), 
			cbWriteLen:= SIZEOF(iStructSize), 
			bExecute:= TRUE, 
			tTimeout:= T#1S);
			
		IF NOT fbFileWrite.bBusy THEN
			IF fbFileWrite.cbWriteLen <> fbFileWrite.cbWrite THEN
				nErrorCode := enRecMan_ErrorList.WriteSizeError;
				iStep:= 99;
			ELSE
				IF fbFileWrite.bError THEN
					iStep:= 99;
					uiErrorID:= fbFileWrite.nErrId;
					nErrorCode := enRecMan_ErrorList.WriteRecipeError;
				ELSE
					iStep:= 30;
				END_IF
			END_IF	
			fbFileWrite(bExecute:= FALSE); 	
		END_IF
		
	30:		// Save Data
		IF bSavePLCStruct THEN
			fbFileWrite(pWriteBuff:= pPLC_Struct);
		ELSE
			fbFileWrite(pWriteBuff:= pTMP_PLC_Struct);
		END_IF
		fbFileWrite(
			hFile:= hFiileHandler, 
			cbWriteLen:= INT_TO_UINT(iPLC_StructSize), 
			bExecute:= TRUE, 
			tTimeout:= T#1S);
		
		IF NOT fbFileWrite.bBusy THEN
			IF fbFileWrite.cbWriteLen <> fbFileWrite.cbWrite THEN
				nErrorCode := enRecMan_ErrorList.WriteSizeError;
				iStep:= 99;
			ELSE
				IF fbFileWrite.bError THEN
					iStep:= 99;
					uiErrorID:= fbFileWrite.nErrId;
					nErrorCode := enRecMan_ErrorList.WriteRecipeError;
				ELSE
					iStep:= 35;
					wCRCsum:= F_DATA_TO_CRC16_CCITT(pData:= fbFileWrite.pWriteBuff, cbData := fbFileWrite.cbWriteLen, crc := 16#0000);
				END_IF
			END_IF		
			fbFileWrite(bExecute:= FALSE); 
		END_IF
		
	35:		// calculate and write CRC check sum
		fbFileWrite(
			hFile:= hFiileHandler, 
			pWriteBuff:= ADR(wCRCsum), 
			cbWriteLen:= SIZEOF(wCRCsum), 
			bExecute:= TRUE, 
			tTimeout:= T#1S);
			
		IF NOT fbFileWrite.bBusy THEN
			IF fbFileWrite.cbWriteLen <> fbFileWrite.cbWrite THEN
				nErrorCode := enRecMan_ErrorList.WriteSizeError;
				iStep:= 99;
			ELSE
				IF fbFileWrite.bError THEN
					iStep:= 99;
					uiErrorID:= fbFileWrite.nErrId;
					nErrorCode := enRecMan_ErrorList.WriteRecipeError;
				ELSE
					iStep:= 40;
				END_IF
			END_IF		
			fbFileWrite(bExecute:= FALSE); 
		END_IF
		
	40:		// Close file
		fbFileClose(
			hFile:= hFiileHandler, 
			bExecute:= TRUE, 
			tTimeout:= T#1S,);
		IF NOT fbFileClose.bBusy THEN
			IF fbFileClose.bError THEN
				iStep:= 99;
				uiErrorID:= fbFileClose.nErrId;
				nErrorCode := enRecMan_ErrorList.FileCloseError;
			ELSE
				iStep:= 50;
			END_IF
			IF bCloseFileAfterError THEN
				bFileOpen R= NOT fbFileClose.bError;
				iStep:= 100;
				bCloseFileAfterError := FALSE;
			END_IF
			fbFileClose(bExecute:= FALSE);
		END_IF
		
	
	50:		// Save success
		bRecipeSave_OK:= TRUE;
		iStep:= 100;
	
	99:
		bRecipeSave_OK:= FALSE;
		IF bFileOpen THEN
			bCloseFileAfterError := TRUE;
			fbFileClose(bExecute:= TRUE); 
			iStep := 40;
		ELSE
			bCloseFileAfterError := FALSE;
			iStep:= 100;
		END_IF
		
	100:
		bWritingRecipe := FALSE;
		fbTON_StepTimeout(IN:= FALSE);
		fbFileOpen(bExecute := FALSE);
		fbFileWrite(bExecute := FALSE);
		fbFileClose(bExecute := FALSE);
		iStep:= 0;
END_CASE

fbTON_StepTimeout(IN:= TRUE, PT:= T#3S);
IF fbTON_StepTimeout.Q THEN
	fbTON_StepTimeout(IN:= FALSE);
	nErrorCode := enRecMan_ErrorList.WriteRecipeTimeout;
	iStep:= 0;
	bReadingRecipe := FALSE;
END_IF
]]></ST>
      </Implementation>
    </Action>
  </POU>
</TcPlcObject>