<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.13">
  <POU Name="fbHP_Axis" Id="{f41e0dee-2020-4b0f-95c8-8a778a61a25d}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK fbHP_Axis ////Blok funkcyjny obslugujacy kompleksowao jedna Os 
VAR_INPUT
	stTestParams			: stHP_Axis_TestParams;		
	stSettings				: stHP_Axis_Settings;
	bEmergencyStop 			: BOOL;			// Emergency stop pressed	
	bSTO_Signal 			: BOOL;			// STO signal activated
	rExternalForce_N		: REAL;
	lrHeatPlateHeight_mm	: LREAL;
	lrMarkingPos_mm			: LREAL;
	I_TimeTableRef			: I_TimeTable255;
	sTTRowPreambule			: STRING;
	bELM_ChB				: BOOL;
END_VAR
VAR_OUTPUT
	nActEvent					: nHP_Axis_ErrorList;
	udiActErrorCode				: UDINT;
	bBasePosRefreshWarning		: BOOL;
	rPartSizeDifference_Mean	: REAL;
END_VAR
VAR
	stInOuts					: stHP_Axis_InOuts;
	bEnableMotion				: BOOL;		// When TRUE - try to enable axis, when FALSE disable power - safeState
	McPower 					: MC_Power;
	McReset 					: MC_Reset;
	McStop	 					: MC_Stop;
	McMoveAbs 					: MC_MoveAbsolute;
	McMoveRel 					: MC_MoveRelative;
	McMoveVelocity	 			: MC_MoveVelocity;
	McJog	 					: MC_Jog;
	McReadActualPosition	 	: MC_ReadActualPosition;
	McReadActualVelocity	 	: MC_ReadActualVelocity;
	McHome						: MC_Home;
	McBrakeCtrl					: FB_BrakeControl;
	
	McTorqueMonitor				: FB_TorqueMonitoringEL_Ex2;
	McTorqueCtrl				: MC_TorqueControl;
	stHomimgParams				: ST_HomingOptions;
		


	fbForceFilter: FB_FilterEx;
	rForceTaraOffset: REAL;
	bTaring: BOOL:= TRUE;
	fbTON_ForceSampling: TON;
	rForceMemory: REAL;
	fbTON_ForceStable: TON;
	fbTON_TaringTimeout: TON;
	bDetectCollision_Active: BOOL;
	fbTOF_Accelerating: TOF;
	rCollisionRecordedForce: REAL;
	bLimitSwitchMin: BOOL;
	bLimitSwitchMax: BOOL;
	iWorkStep_Axis: INT;
	iWorkStep_Alghorithm: INT;
	fbFTrig_EmergStop: F_TRIG;
	bDoneReceived: BOOL;
	fbTON_WorkStepTimeout: TON;
	bAlg_Busy, bAlg_Error : BOOL;
	udiAlg_ErrorId	: UDINT;
	iPresenceSensorWorkVerify: INT;
	bHP_InWorkPos: BOOL;
	rMeltingDelay_ms: REAL;	
	lrAdjContactPoint_mm: LREAL;
	lrHeatUpPos_mm: LREAL;
	fbTON_WorkStepTime_Alg: TON;
	bAllowToDepartAfterHeatUp: BOOL;
	rAdhesionMaxForce: REAL;
	bHP_InHomePos: BOOL;
	fbMc_ForcePID: PID;
	bMeltingActive: BOOL;
	bConnectionMinForceReached: BOOL;

	bWeldResultReaded: BOOL;
	bPID_ForceRegulation: BOOL;
	lrConnectionContactPoint_mm, lrConnectionContactPointDif_mm: LREAL;
	udiMcError: UDINT;
	bStartConnecting: BOOL;
	bConnectingActive: BOOL;
	bTearingTestActive: BOOL;
	bPartsConnected: BOOL;
	fbTON_ManualJogReset: TON;
	udiErrorCodeToRead: UDINT;
	udiMcErrorToRead: UDINT;

	fbRTRIG_ManGoForward: R_TRIG;
	bManModeForceMax: BOOL;
	bTouchingHP: BOOL;
	bOnlySafeState: BOOL;
	lrCalibrationPoint_mm: LREAL;
	bPartBaseCalibration: BOOL;
	bHMI_Plus, bHMI_Minus: BOOL;
	bResetTmr: BOOL;
	
	rMeltingTime: REAL;
	bSetNewBrakeCtrl: BOOL;
	nAct_BrakeMode, nNew_BrakeMode: nHP_Axis_BrakeMode;
	fbFTRIG_BreakCtrlDone: F_TRIG;
	bTooglePowerState: BOOL;
	bManModeMoveSlower: BOOL;
	fbRTRIG_ManMoveSwitchSlower: R_TRIG;
	lrPartSizeDifference: LREAL;
	iHMI_StepName: INT;
	rConnectingMaxForce: REAL;
	lrTmp: LREAL;
	astErrorHistory: ARRAY [1..10] OF stErrorHistoryRow;
	bTestContRegulation: BOOL;
	iTestPIR_Reg: INT;
	lrPID_StartPos: LREAL;
	bWaitForSP: BOOL;
	lrMeltingPrevPosition: LREAL;
	lrMeltingEnergyCalculation: LREAL;
END_VAR
VAR PERSISTENT
	lrBasePos_mm		: LREAL;
END_VAR
VAR_IN_OUT
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[
// Read drive data
stInOuts.stAxis_Data.ReadStatus();
McReadActualPosition(Axis := stInOuts.stAxis_Data, Enable := TRUE);
McReadActualVelocity(Axis := stInOuts.stAxis_Data, Enable := TRUE);

//Read FB status
ACT_AxisFBs(); 	

ACT_BackgroundTasks();
ACT_AxisWorkSteps();
ACT_AxisFBs(); 	
ACT_WeldingAlghorithm();


IF IsReady AND iWorkStep_Alghorithm = 10	THEN	// Ready for new operation
	iHMI_StepName:= 12;
ELSIF iWorkStep_Alghorithm = 90 OR (iWorkStep_Axis >= 90 AND iWorkStep_Axis < 95) THEN		// Error
	iHMI_StepName:= 17;
ELSIF iWorkStep_Axis = 15 THEN		// Error
	iHMI_StepName:= 11;
ELSIF iWorkStep_Alghorithm >= 15 AND iWorkStep_Alghorithm <= 20 THEN		// Going to PreAdjustment position, waiting for eject HeatedPlate
	iHMI_StepName:= 22;
ELSIF iWorkStep_Alghorithm = 25 THEN		// Melting start delay - simultaneous departure
	iHMI_StepName:= 23;
ELSIF iWorkStep_Alghorithm >= 30 AND iWorkStep_Alghorithm < 33 THEN		// Melting in progress
	iHMI_StepName:= 24;
ELSIF iWorkStep_Alghorithm = 33 THEN		// Heating UP
	iHMI_StepName:= 25;
ELSIF iWorkStep_Alghorithm = 35 THEN		// Wait for permission to departure
	iHMI_StepName:= 26;
ELSIF iWorkStep_Alghorithm >= 40 AND iWorkStep_Alghorithm <= 45 THEN		// Departure from Heated Plate 
	iHMI_StepName:= 27;
ELSIF iWorkStep_Alghorithm = 50 THEN		// Wait for Heated Plate return 
	iHMI_StepName:= 28;
ELSIF iWorkStep_Alghorithm = 55 THEN		// Move to connection position 
	iHMI_StepName:= 29;
ELSIF iWorkStep_Alghorithm >= 56 AND iWorkStep_Alghorithm < 60 THEN		// Connecting 
	iHMI_StepName:= 30;
ELSIF iWorkStep_Alghorithm = 60 THEN		// Cooling down 
	iHMI_StepName:= 31;
	

	
END_IF

]]></ST>
    </Implementation>
    <Folder Name="Methods" Id="{597ebe3c-cbbd-4068-938a-07f612a92b48}" />
    <Folder Name="Properties" Id="{226561ff-aa2a-41c1-a914-5dd8fa88bbf3}">
      <Folder Name="InPos" Id="{12181ec2-db86-466c-ac20-e1afa39ee7b7}" />
    </Folder>
    <Action Name="ACT_AxisFBs" Id="{2e6f3302-7bcc-40e0-a567-adc7e373f042}">
      <Implementation>
        <ST><![CDATA[
// Power ON
IF NOT bELM_ChB THEN
	bLimitSwitchMin	:= NOT stInOuts.wI_DriveInfodata.0;
	bLimitSwitchMax	:= NOT stInOuts.wI_DriveInfodata.1;	
ELSE
	bLimitSwitchMin	:= NOT stInOuts.wI_DriveInfodata.8;
	bLimitSwitchMax	:= NOT stInOuts.wI_DriveInfodata.9;	
END_IF
McPower(Axis:=stInOuts.stAxis_Data, Enable:=, Enable_Positive:=NOT bLimitSwitchMax, Enable_Negative:= (NOT bLimitSwitchMin OR McHome.Active));

// Error reset
McReset(Axis:=stInOuts.stAxis_Data);

// Homing
McHome(Axis := stInOuts.stAxis_Data, Position := 0, HomingMode := MC_HomingMode.MC_DefaultHoming, bCalibrationCam := bLimitSwitchMin, Options := stHomimgParams);

// Stop FBs
McStop(Axis := stInOuts.stAxis_Data, Deceleration := 15000, Jerk := 100000);
McBrakeCtrl(Axis := stInOuts.stAxis_Data);
fbFTRIG_BreakCtrlDone(CLK:= McBrakeCtrl.Busy);
IF fbFTRIG_BreakCtrlDone.Q THEN
	IF McBrakeCtrl.Mode = eBrakeMode_Automatic THEN	nAct_BrakeMode := nHP_Axis_BrakeMode.BrakeMode_Automatic;
	ELSIF McBrakeCtrl.Mode = eBrakeMode_Lock THEN nAct_BrakeMode := nHP_Axis_BrakeMode.BrakeMode_Lock;
	ELSIF McBrakeCtrl.Mode = eBrakeMode_Unlock THEN nAct_BrakeMode := nHP_Axis_BrakeMode.BrakeMode_Unlock;
	END_IF
END_IF
McBrakeCtrl.Execute := FALSE;
// Motion FBs

McJog(Axis := stInOuts.stAxis_Data, Mode := MC_JOGMODE_CONTINOUS, Acceleration := stSettings.rAcceleration, Deceleration := stSettings.rDeceleration, Jerk := 100000);
McMoveAbs(Axis := stInOuts.stAxis_Data, Acceleration := stSettings.rAcceleration, Deceleration := stSettings.rDeceleration, Jerk := 100000);
McMoveRel(Axis := stInOuts.stAxis_Data, Acceleration := stSettings.rAcceleration, Deceleration := stSettings.rDeceleration, Jerk := 100000);
McMoveVelocity(Axis := stInOuts.stAxis_Data, Acceleration := stSettings.rAcceleration, Deceleration := stSettings.rDeceleration, Jerk := 100000);

// Torque limitation
McTorqueMonitor( bCalculate:= bSTO_Signal,
	rTorqueLimit:= ,
	Axis:= stInOuts.stAxis_Data);
McTorqueCtrl(Axis := stInOuts.stAxis_Data, Relative := FALSE, ContinuousUpdate := TRUE, TorqueRamp := 100);]]></ST>
      </Implementation>
    </Action>
    <Action Name="ACT_AxisWorkSteps" Id="{cad37b5b-c990-4e5d-bc85-7df886766db3}">
      <Implementation>
        <ST><![CDATA[
fbFTrig_EmergStop(CLK:= bEmergencyStop);
IF fbFTrig_EmergStop.Q THEN
	iWorkStep_Axis := 90;
END_IF
IF NOT bEmergencyStop AND iWorkStep_Axis < 90 THEN
	mNewEvent(nEvent := nHP_Axis_ErrorList.STO_SignalActive, ErrorCode:= 0);
	bOnlySafeState := FALSE;
ELSIF NOT bEnableMotion AND Enabled AND bEmergencyStop AND iWorkStep_Axis > 5 AND iWorkStep_Axis < 92 THEN		// Regular disable (when opewn workcover)
	iWorkStep_Axis := 92;
END_IF

CASE iWorkStep_Axis OF
	0:	// Inicjalizacja
		McPower.Enable := McReset.Execute := McHome.Execute := McStop.Execute := FALSE;
		McJog.JogForward := McJog.JogBackwards := McMoveAbs.Execute := McMoveRel.Execute := McMoveVelocity.Execute := FALSE; 
		iWorkStep_Axis := 1;
		
	1:	// Sprawdzenie parametrów pracy
		stSettings.rSlowSpeed_mm_s := LIMIT(0.5, stSettings.rSlowSpeed_mm_s, 10);
		stSettings.rFastSpeed_mm_s := LIMIT(50, stSettings.rFastSpeed_mm_s, 320);
		stSettings.rDeceleration := LIMIT(100, stSettings.rDeceleration, 5000);
		stSettings.rAcceleration := LIMIT(100, stSettings.rAcceleration, 5000);
		stSettings.lrMax_Pos := LIMIT(100, stSettings.lrMax_Pos, 300); 
		iWorkStep_Axis := 5;
		
	5: 	// Sprawdzenie gotowości do załączenia
		IF IsErrorActive THEN
			mNewEvent( nEvent := nHP_Axis_ErrorList.MotionFB_Error,ErrorCode:= stInOuts.stAxis_Data.Status.ErrorID);
		END_IF
		IF McPower.Enable THEN
			IF McPower.Status THEN
				iWorkStep_Axis := 10;
			ELSIF McPower.Error THEN
				mNewEvent( nEvent := nHP_Axis_ErrorList.MotionFB_Error,ErrorCode:= McPower.ErrorID);
			END_IF
		ELSE 
			IF bEnableMotion THEN
				bOnlySafeState := FALSE;
				McPower.Enable :=  TRUE;
			END_IF
		END_IF
		
	10:	// Axis ready for new Cmds
		IF IsErrorActive THEN
			mNewEvent( nEvent := nHP_Axis_ErrorList.MotionFB_Error,ErrorCode:= stInOuts.stAxis_Data.Status.ErrorID);
		END_IF
		fbTON_WorkStepTimeout(IN:= FALSE);
		bDoneReceived := FALSE;
		
	15:	// Manual mode
		IF bResetTmr THEN
			bResetTmr := FALSE;
			fbTON_ManualJogReset(IN:= FALSE);
		END_IF
		fbTON_ManualJogReset(IN:= McJog.Active, PT:= T#250MS);
		IF fbTON_ManualJogReset.Q THEN
			McJog.JogForward := McJog.JogBackwards := FALSE;
		END_IF
		// Breake control
		IF bSetNewBrakeCtrl THEN
			McBrakeCtrl.Mode := nNew_BrakeMode;
			McBrakeCtrl.Execute := TRUE;	
			bSetNewBrakeCtrl := FALSE; 
		// Enable/disable axis
		ELSIF bTooglePowerState THEN
			McPower.Enable := NOT McPower.Enable;
 			bTooglePowerState := FALSE;
		ELSE
			McPower.Enable S= McJog.JogForward OR McJog.JogBackwards;
		END_IF	
	
	20:	// Homing
		IF McHome.Execute THEN
			IF McHome.Done THEN
				fbTON_WorkStepTimeout(IN:= FALSE);
				iWorkStep_Axis := 21;		// Acurate
			ELSIF McHome.Error THEN
				mNewEvent( nEvent := nHP_Axis_ErrorList.MotionFB_Error,ErrorCode:= McHome.ErrorID);
		//	ELSIF NOT McHome.Busy THEN
		//		mNewEvent( nEvent := nHP_Axis_ErrorList.MotionFB_NotBusy,ErrorCode:= 0);
			END_IF
		ELSE 
			stHomimgParams.SearchDirection := MC_Direction.MC_Negative_Direction;
			stHomimgParams.SyncDirection := MC_Direction.MC_Positive_Direction;
			stHomimgParams.SearchVelocity := 30.0;
			stHomimgParams.SyncVelocity := 1;
			stHomimgParams.ReferenceMode := E_EncoderReferenceMode.ENCODERREFERENCEMODE_DEFAULt;
			McHome.Execute := TRUE;
		END_IF
			
	21:	// Home done
		fbTON_WorkStepTimeout(IN:= TRUE,PT:=T#100MS);
		IF bDoneReceived OR fbTON_WorkStepTimeout.Q THEN
			McHome.Execute := FALSE;
			iWorkStep_Axis := 10;	
		END_IF
		
	30:	// Move to absolute position
		IF McMoveAbs.Execute THEN
			IF McMoveAbs.Done THEN
				iWorkStep_Axis := 31;		// Done
			ELSIF McMoveAbs.Error THEN
				mNewEvent(nEvent := nHP_Axis_ErrorList.MotionFB_Error, ErrorCode:= McMoveAbs.ErrorID);
		//	ELSIF NOT McMoveAbs.Busy THEN
		//		mNewEvent(nEvent := nHP_Axis_ErrorList.MotionFB_NotBusy,ErrorCode:= 0);
			END_IF
		ELSE 
			McMoveAbs.Execute := TRUE;
		END_IF
	
	31:	// Move ABS done
		fbTON_WorkStepTimeout(IN:= TRUE,PT:=T#100MS);
		IF bDoneReceived OR fbTON_WorkStepTimeout.Q THEN
			McMoveAbs.Execute := FALSE;
			iWorkStep_Axis := 10;	
		END_IF
		
	40:	// Calibrate axis - base axis
		bBasePosRefreshWarning := bPartBaseCalibration := FALSE;
		rPartSizeDifference_Mean := 0.0;
		fbTON_WorkStepTimeout(IN:= TRUE,PT:=T#1S);
		IF McMoveVelocity.Execute THEN
			IF NOT fbTOF_Accelerating.Q AND fbTON_ForceStable.Q THEN
				fbTON_WorkStepTimeout(IN:= FALSE);
				bTaring := TRUE;
				iWorkStep_Axis := 41;
			END_IF
		ELSE 
			IF IsHomed THEN
				McMoveVelocity.Execute := TRUE;
				McMoveVelocity.Direction := MC_Direction.MC_Positive_Direction;
				McMoveVelocity.Velocity := stSettings.rSlowSpeed_mm_s;
			END_IF
		END_IF
		IF fbTON_WorkStepTimeout.Q THEN
			mNewEvent(nEvent := nHP_Axis_ErrorList.MotionFB_Error, ErrorCode:= INT_TO_UDINT(iWorkStep_Axis));
		END_IF
	
	41:	// Wait for taring
		fbTON_WorkStepTimeout(IN:= TRUE,PT:=T#2S);
		IF NOT bTaring THEN
			lrCalibrationPoint_mm := 0.0;
			McMoveVelocity.Execute := FALSE;
			fbTON_WorkStepTimeout(IN:= FALSE);
			iWorkStep_Axis := 42;
		ELSIF fbTON_WorkStepTimeout.Q THEN
			mNewEvent(nEvent := nHP_Axis_ErrorList.ForceTaringError, ErrorCode:= INT_TO_UDINT(iWorkStep_Axis));			
		END_IF
		
	42:	// Wait for contact - force rising
		fbTON_WorkStepTimeout(IN:= TRUE,PT:=T#4M);
		IF ActualForce >= stTestParams.rAdjContactDetectForce_N THEN
			lrCalibrationPoint_mm := ActualPosition;
			IF bPartBaseCalibration THEN
				lrBasePos_mm := lrCalibrationPoint_mm;
			END_IF
			McMoveRel.Execute := TRUE;
			McMoveRel.Distance := -10.0;
			McMoveRel.Velocity := 5*stSettings.rSlowSpeed_mm_s;
			iWorkStep_Axis := 43;
		END_IF
		IF fbTON_WorkStepTimeout.Q OR InSetPos_MaxPos THEN
			mNewEvent(nEvent := nHP_Axis_ErrorList.BasePosSearchTimeout, ErrorCode:= INT_TO_UDINT(iWorkStep_Axis));			
		END_IF

	43:	// Reverse axis to safe position 
		IF McMoveRel.Execute THEN
			IF  McMoveRel.Done THEN
				fbTON_WorkStepTimeout(IN:= FALSE);
				McMoveRel.Execute := FALSE;
				iWorkStep_Axis := 44;
			ELSIF McMoveRel.Error THEN
				mNewEvent(nEvent := nHP_Axis_ErrorList.MotionFB_Error, ErrorCode:= McMoveRel.ErrorID);
			END_IF
		ELSE 
			McMoveRel.Execute := TRUE;
			McMoveRel.Distance := -10.0;
			McMoveRel.Velocity := 5*stSettings.rSlowSpeed_mm_s;
		END_IF 
		
	44:	// Wait for result readed
		fbTON_WorkStepTimeout(IN:= TRUE,PT:=T#100MS);
		IF bDoneReceived OR fbTON_WorkStepTimeout.Q THEN
			bPartBaseCalibration := FALSE;
			iWorkStep_Axis := 10;	
		END_IF
		
	90:	// Go to Safe position
		McMoveVelocity.Execute := McMoveAbs.Execute := McMoveRel.Execute := McStop.Execute := FALSE;
		iWorkStep_Axis := 92;		// Domyślnie tylko wyłącz napęd
		IF Enabled AND NOT stInOuts.stAxis_Data.Status.Error AND (IsHomed AND ActualPosition > 20) THEN// AND (bTouchingHP OR (ActualForce > 20 AND NOT bTaring) ) THEN	// Drive homed, ready and position is greather than load position - reverse fixture
			PartClamp := TRUE;
			iWorkStep_Axis := 91;		
		END_IF
		
	91:	// Reverse fixture which is potentially touches heated plate
		IF McMoveRel.Execute THEN
			IF  McMoveRel.Done OR NOT bSTO_Signal THEN
				McMoveRel.Execute := FALSE;
				iWorkStep_Axis := 92;
			ELSIF McMoveRel.Error THEN
				mNewEvent(nEvent := nHP_Axis_ErrorList.MotionFB_Error, ErrorCode:= McMoveRel.ErrorID);
				// NOthing to do
				McMoveRel.Execute := FALSE;
				iWorkStep_Axis := 92;
			END_IF
		ELSIF stInOuts.stAxis_Data.Status.Operational AND NOT McMoveRel.Execute THEN 
			McMoveRel.Execute := TRUE;
			McMoveRel.Distance := -30.0;
			McMoveRel.Velocity := stSettings.rFastSpeed_mm_s;
		END_IF 
	
	92:	// Stop drive and disable power
		IF McStop.Execute THEN
			IF McStop.Done OR NOT Enabled OR McStop.Error THEN	// Disable axis - cant do anything
				McStop.Execute := FALSE;
				McPower.Enable := FALSE;
				IF bOnlySafeState THEN
					bOnlySafeState := FALSE;				
					iWorkStep_Axis := 5;	
				ELSE
					iWorkStep_Axis := 94;	
				END_IF

			END_IF
		ELSE 
			IF Enabled THEN
				McStop.Execute := TRUE;
			ELSE
				IF bOnlySafeState THEN
					bOnlySafeState := FALSE;				
					iWorkStep_Axis := 5;	
				ELSE
					iWorkStep_Axis := 94;	
				END_IF				
			END_IF
		END_IF 
		
	94:	// Axis wait for reset	- NOP
		bConnectingActive := bMeltingActive := McReset.Execute := FALSE;
		fbTON_WorkStepTimeout(IN:= FALSE);
	
	95: // Axis reset
		bOnlySafeState := FALSE;
		PartClamp := FALSE;
		iWorkStep_Alghorithm := 0;
		fbTON_WorkStepTimeout(IN:= TRUE,PT:=T#2S);
		IF McReset.Execute THEN
			IF McReset.Done THEN	// Reset axis
				McReset.Execute := FALSE;
				fbTON_WorkStepTimeout(IN:= FALSE);
				iWorkStep_Axis := 96;
			ELSIF McReset.Error THEN		//NOT McReset.Busy OR 
				McReset.Execute := FALSE;
				iWorkStep_Axis := 97;
			END_IF
		ELSE 
			McHome.Execute := McStop.Execute := McJog.JogForward := McJog.JogBackwards := FALSE;
			McMoveAbs.Execute := McMoveRel.Execute := McMoveVelocity.Execute := FALSE; 
			IF stInOuts.stAxis_Data.Status.Error THEN
				McReset.Execute := TRUE;
			ELSE
				fbTON_WorkStepTimeout(IN:= FALSE);
				iWorkStep_Axis := 96;
			END_IF
		END_IF
		
	96:	// Reset succesfull
		nActEvent := nHP_Axis_ErrorList.NoError;
		fbTON_WorkStepTimeout(IN:= TRUE, PT:= T#40MS);
		IF fbTON_WorkStepTimeout.Q THEN
			fbTON_WorkStepTimeout(IN:= FALSE);
			iWorkStep_Axis := 5;
		END_IF
		
	97:	// Reset error
		nActEvent := nHP_Axis_ErrorList.MotionFB_Error;
		iWorkStep_Axis := 90;	
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="ACT_BackgroundTasks" Id="{28dc931d-9390-4704-89d9-1706a6e5b6ab}">
      <Implementation>
        <ST><![CDATA[// General signal preparation

// Force measurement	----------------------------------------------------------------------------------
fbForceFilter(rIn := stInOuts.stLoadCell_Data.rValue+rForceTaraOffset, tTimeConstant := T#20MS);
fbTON_ForceSampling(IN:= NOT fbTON_ForceSampling.Q, PT:= T#30MS);
IF fbTON_ForceSampling.Q THEN
	fbTON_ForceStable(IN:= ABS(rForceMemory-ActualForce)< MAX(0.9,ActualForce*0.11), PT:= T#100MS);
	rForceMemory := ActualForce;
END_IF

IF bTaring THEN
	IF fbTON_ForceStable.Q THEN
		rForceTaraOffset := rForceTaraOffset - ActualForce;
		bTaring := FALSE;
	ELSE
		IF fbTON_TaringTimeout.Q THEN
			bTaring := FALSE;
			mNewEvent(nEvent := nHP_Axis_ErrorList.ForceTaringError, ErrorCode:= REAL_TO_UDINT(ActualForce));
		END_IF
	END_IF
END_IF
fbTON_TaringTimeout(IN:= bTaring, PT:= T#1S);		

// Colision detection	----------------------------------------------------------------------------------
fbTOF_Accelerating(IN:= stInOuts.stAxis_Data.Status.Accelerating OR bTaring,PT:= T#40MS);
IF bDetectCollision_Active AND_THEN stSettings.bColisionDettection_EN AND NOT ManualMode AND
		(ActualForce >= stSettings.rCollisionDetectForce_N AND NOT fbTOF_Accelerating.Q OR ABS(ActualForce) >= 2*stSettings.rCollisionDetectForce_N) THEN
	bDetectCollision_Active := FALSE;
	rCollisionRecordedForce := ActualForce;
	mNewEvent(nEvent := nHP_Axis_ErrorList.ColisionDetected, ErrorCode:= REAL_TO_UDINT(ActualForce));
	McStop.Execute := TRUE;
	GVL_Aircom.fbFormatString(sFormat := 'Kolizja wykryta, pozycja %.3f[mm], sila kolizji %.2f[N]',
			 arg1:= F_LREAL(McReadActualPosition.Position),
			 arg2:= F_REAL(rCollisionRecordedForce));
	mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
END_IF


// Force regulation when melting active	----------------------------------------------------------------------------------
fbMc_ForcePID(
	KP:= 1.2,
	TN:= 0.36,
	TV:= 0.0,
	Y_MANUAL:= 0.0,//SEL(bMeltingActive AND fbMc_ForcePID.ACTUAL<fbMc_ForcePID.SET_POINT,0.0, ActualVelocity/2), 
	Y_OFFSET:= 0.0, 
	Y_MIN:= 0.2, 
	Y_MAX:= 100*stSettings.rSlowSpeed_mm_s, 
	MANUAL:= bWaitForSP OR NOT bMeltingActive OR NOT bPID_ForceRegulation, 
	RESET:=, 
	Y=> );

CASE iTestPIR_Reg OF 
	0:	
		IF bTestContRegulation AND ManualMode AND NOT bMeltingActive THEN
			McStop.Execute := FALSE;
			lrPID_StartPos := ActualPosition;
			iTestPIR_Reg := 5;
		END_IF
	5:	
		McMoveVelocity.Direction := MC_Direction.MC_Positive_Direction;
		McMoveVelocity.Velocity := stSettings.rSlowSpeed_mm_s;
		McMoveVelocity.Execute := TRUE;	
		IF McMoveVelocity.Busy THEN
			fbMc_ForcePID.SET_POINT := fbMc_ForcePID.SET_POINT; 
			fbMc_ForcePID.ACTUAL := ActualForce;
			bPID_ForceRegulation := bMeltingActive:= TRUE;
			iTestPIR_Reg := 10;
		END_IF
	10:
		fbMc_ForcePID.ACTUAL := ActualForce;
		McJog.JogForward := McJog.JogBackwards := FALSE;
		IF NOT bTestContRegulation OR (ActualPosition > (lrPID_StartPos+50)) THEN
			bPID_ForceRegulation := bMeltingActive := McMoveVelocity.Execute := FALSE;
			McStop.Execute := TRUE;
			iTestPIR_Reg := 15;
 		END_IF
	15:	
		IF McStop.Done THEN
			bMeltingActive := bTestContRegulation := FALSE;
			McStop.Execute := FALSE;
			iTestPIR_Reg := 0;
		ELSIF McStop.Error THEN
			mNewEvent(nEvent := nHP_Axis_ErrorList.MotionFB_Error, ErrorCode:= McStop.ErrorID);
		END_IF		
END_CASE

IF bMeltingActive OR bConnectingActive THEN
	McMoveVelocity.Direction:= MC_Direction.MC_Positive_Direction;
	IF bPID_ForceRegulation THEN
		bWaitForSP R= fbMc_ForcePID.ACTUAL<fbMc_ForcePID.SET_POINT ;
		McMoveVelocity(Axis := stInOuts.stAxis_Data, Execute := FALSE);
		McMoveVelocity.Velocity :=  REAL_TO_LREAL(fbMc_ForcePID.Y)/100;
		McMoveVelocity(Axis := stInOuts.stAxis_Data, Execute := TRUE);
	ELSE
		McMoveVelocity.Velocity := stSettings.rSlowSpeed_mm_s/2;
		IF fbMc_ForcePID.ACTUAL < fbMc_ForcePID.SET_POINT AND NOT McStop.Execute THEN
			McMoveVelocity.Execute := TRUE;
		ELSIF fbMc_ForcePID.ACTUAL >= fbMc_ForcePID.SET_POINT AND NOT McStop.Execute AND IsMoving THEN
			McStop.Execute := TRUE;
			McMoveVelocity.Execute := FALSE;
		END_IF
		IF McStop.Done THEN
			McStop.Execute := FALSE;
		ELSIF McStop.Error THEN
			bMeltingActive := bConnectingActive := FALSE;
			mNewEvent(nEvent := nHP_Axis_ErrorList.MotionFB_Error, ErrorCode:= McStop.ErrorID);
		END_IF
	END_IF
END_IF]]></ST>
      </Implementation>
    </Action>
    <Action Name="ACT_WeldingAlghorithm" Id="{e262e1d3-a035-43d2-af4c-e0752d3bd8d1}">
      <Implementation>
        <ST><![CDATA[		

CASE iWorkStep_Alghorithm OF
	0:		// Check if
		fbTON_WorkStepTime_Alg(IN:= FALSE);
		bMeltingActive := bConnectingActive := bDetectCollision_Active := FALSE;
		iWorkStep_Alghorithm := 10;
		
	10: 	// Waiting for new operation
		IF NOT PartSensorState THEN
			iPresenceSensorWorkVerify:= 0;	
		END_IF
		
	15:		// Reset test data and test preconditions (if part is present)
		lrAdjContactPoint_mm := lrMeltingEnergyCalculation := lrHeatUpPos_mm := 0.0;
		lrConnectionContactPoint_mm := 0.0;
		rMeltingTime := rCollisionRecordedForce := rConnectingMaxForce := 0.0;
		bWaitForSP := FALSE;
		IF stSettings.bPartInFixtureDetection_EN THEN 
			IF iPresenceSensorWorkVerify > 3 THEN
				mNewEvent(nEvent:= nHP_Axis_ErrorList.PartDetectSensorFailure, ErrorCode := 0);
			ELSIF NOT PartSensorState THEN	// Jeśli włączona detekcja części a nie ma jej w uchwycie - błąd
				mNewEvent(nEvent:= nHP_Axis_ErrorList.PartNotDetectedInFixture, ErrorCode := 0);
			ELSE
				mAddTimeStat(sText := 'Czesc obecna w uchwycie');
				iPresenceSensorWorkVerify:= iPresenceSensorWorkVerify + 1;
				bTaring := TRUE;
				iWorkStep_Alghorithm := 16;
			END_IF
		ELSE
			bTaring := TRUE;
			iWorkStep_Alghorithm := 16;
		END_IF
		fbTON_WorkStepTime_Alg(IN:= FALSE);
			
	16:		// Wait for taring
		fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#1S);
		PartClamp S= NOT stTestParams.bPartLockAfterHpContact;
		IF NOT bTaring THEN
			fbTON_WorkStepTime_Alg(IN:= FALSE);
			iWorkStep_Alghorithm := 17;
		ELSIF fbTON_WorkStepTime_Alg.Q THEN
			mNewEvent(nEvent := nHP_Axis_ErrorList.ForceTaringError, ErrorCode:= REAL_TO_UDINT(ActualForce));
		END_IF

	17:		// Part level adjusting and melting
		fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#3S);
		bDetectCollision_Active := TRUE;
		bPartsConnected := FALSE;
		// Go on safe position and wait for HP open signal
		IF mMoveFastToPresetPos(nSetPos := nHP_Axis_PresetPositions.SafeHpMove_Pos,bError => bAlg_Error)
					AND_THEN NOT bAlg_Error THEN
			mAddTimeStat(sText := 'Oczekiwanie w pozycji bezpiecznej na otwarcie plyty grzejnej');
			iWorkStep_Alghorithm := 20;
		ELSIF fbTON_WorkStepTime_Alg.Q OR bAlg_Error THEN
			mNewEvent(nEvent:= nHP_Axis_ErrorList.MotionWorkStepTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
		END_IF
		IF iWorkStep_Alghorithm <> 15 THEN fbTON_WorkStepTime_Alg(IN:= FALSE); END_IF
		
	20:		// Wait for HP open signal and Go to pre base point
		IF bHP_InWorkPos THEN
			fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#3S);
			IF mMoveFastToPresetPos(nSetPos := nHP_Axis_PresetPositions.PreBase_Pos,bError => bAlg_Error) 
					AND_THEN NOT bAlg_Error THEN
				mAddTimeStat(sText := 'Oczekiwanie na start dopasowania');
				iWorkStep_Alghorithm := 25;
			ELSIF fbTON_WorkStepTime_Alg.Q OR bAlg_Error THEN
				mNewEvent(nEvent:= nHP_Axis_ErrorList.MotionWorkStepTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
			END_IF
		END_IF
		IF iWorkStep_Alghorithm <> 20 THEN fbTON_WorkStepTime_Alg(IN:= FALSE); END_IF
		
	25:		// Wait in prebase position for permision to start adjustment (time synchronization)
		bDetectCollision_Active := FALSE;
		IF rMeltingDelay_ms <100 OR fbTON_WorkStepTime_Alg.Q THEN
			mAddTimeStat(sText := 'Start dopasowania');
			fbTON_WorkStepTime_Alg(IN:= FALSE);
			iWorkStep_Alghorithm := 30;
		ELSE
			fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= REAL_TO_TIME(rMeltingDelay_ms));
		END_IF
		
	30:		// Adjusting by melting part- looking for contact point
		fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#5S);
		IF McMoveVelocity.Execute THEN
			IF ActualForce >= stTestParams.rAdjContactDetectForce_N THEN
				lrAdjContactPoint_mm := ActualPosition;
				lrPartSizeDifference := lrAdjContactPoint_mm - lrBasePos_mm; 
				fMeanFilter(rInputValue:= LREAL_TO_REAL(lrPartSizeDifference), rDelta := 10, rMeanValue := rPartSizeDifference_Mean);
			
				IF stTestParams.bCheckPartToleranceAfterContact AND_THEN ABS(lrPartSizeDifference) > stTestParams.lrPartToleranceFromBasePos_mm THEN
					IF (lrPartSizeDifference) > 0 THEN
						
						mNewEvent(nEvent:= nHP_Axis_ErrorList.PartDimmOutsideToleranceToLow, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
					ELSE
						mNewEvent(nEvent:= nHP_Axis_ErrorList.PartDimmOutsideToleranceToHigh, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
					END_IF
				ELSE
					GVL_Aircom.fbFormatString(sFormat := 'Kontakt czesci osiagniety, pozycja %.3f[mm], roznica wzgledem bazy %.3f[mm]',
							 arg1:= F_LREAL(lrAdjContactPoint_mm),
							 arg2:= F_LREAL(lrPartSizeDifference));
					mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
					bBasePosRefreshWarning S= ABS(rPartSizeDifference_Mean) > 0.75*LREAL_TO_REAL(stTestParams.lrPartToleranceFromBasePos_mm);
					fbTON_WorkStepTime_Alg.PT:= REAL_TO_TIME(stTestParams.rMeltingTimeout_s*1000);
					bWaitForSP := TRUE;
					lrMeltingPrevPosition := ActualPosition;
					iWorkStep_Alghorithm := 31;
				END_IF
			ELSIF (ActualPosition - lrBasePos_mm) > 1.5*(stTestParams.lrPartToleranceFromBasePos_mm) AND stTestParams.lrPartToleranceFromBasePos_mm > 0.02 THEN
				mNewEvent(nEvent:= nHP_Axis_ErrorList.AdjustmentContactForceNotDetected, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
			END_IF
		ELSE
			McMoveVelocity.Direction := MC_Direction.MC_Positive_Direction;
			McMoveVelocity.Velocity := stSettings.rSlowSpeed_mm_s;
			McMoveVelocity.Execute := TRUE;
		END_IF
		IF fbTON_WorkStepTime_Alg.Q THEN
			McMoveVelocity.Execute := FALSE;
			mNewEvent(nEvent:= nHP_Axis_ErrorList.AdjustmentContactDetectionTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
		END_IF
		
	31:		// Level adjustment by melting part	
		fbTON_WorkStepTime_Alg(IN:= TRUE);
		PartClamp S= ActualForce > 0.75*(stTestParams.rMeltingForce_N);
		bMeltingActive:= TRUE;
		fbMc_ForcePID.SET_POINT := stTestParams.rMeltingForce_N; 
		fbMc_ForcePID.ACTUAL := ActualForce;
		bPID_ForceRegulation := stTestParams.bMeltingForceRegulation;
		lrMeltingEnergyCalculation := lrMeltingEnergyCalculation + 0.01*ActualForce*(ActualPosition - lrMeltingPrevPosition);	// Obliczanie energii
		lrMeltingPrevPosition := ActualPosition;
		IF fbTON_WorkStepTime_Alg.Q THEN
			mNewEvent(nEvent:= nHP_Axis_ErrorList.AdjustmentDistnaceNotReachTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
		ELSE
			CASE stTestParams.nMeltingMode OF
				nHP_Axis_AdjustmentModes.FitByDRM:
					IF ActualPosition >= (lrAdjContactPoint_mm + stTestParams.lrMeltingDistance_mm) THEN
						rMeltingTime:= TIME_TO_REAL(fbTON_WorkStepTime_Alg.ET)/1000.0;
						iWorkStep_Alghorithm := 32; 
						GVL_Aircom.fbFormatString(sFormat := 'Osiagnieto droge dopasowania w czasie %.1f[s] (pozycja %.3f[mm], energia %.3f[J])',
							arg1:= F_REAL(rMeltingTime),
							arg2:= F_LREAL(McReadActualPosition.Position),
							arg3:= F_LREAL(lrMeltingEnergyCalculation));
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
					END_IF

				nHP_Axis_AdjustmentModes.FitByABS:
					IF ActualPosition >= (stTestParams.lrMeltingDistance_mm) THEN
						rMeltingTime:= TIME_TO_REAL(fbTON_WorkStepTime_Alg.ET)/1000.0;
						iWorkStep_Alghorithm := 32; 
						lrTmp := ActualPosition - lrAdjContactPoint_mm;
						GVL_Aircom.fbFormatString(sFormat := 'Osiagnieto odleglosc ABS w czasie %.1f[s] (droga dopasowania %.3f[mm], energia %.3f[J])',
							arg1:= F_REAL(rMeltingTime),
							arg2:= F_LREAL(lrTmp),
							arg3:= F_LREAL(lrMeltingEnergyCalculation));
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
					END_IF		
			END_CASE
			IF iWorkStep_Alghorithm <> 31 THEN
				bMeltingActive:= FALSE;
				McMoveVelocity.Execute := FALSE;
				McStop.Execute := TRUE;
				fbTON_WorkStepTime_Alg(IN:= FALSE); 
			END_IF
		END_IF
			
	32:		// Halt after achieved target melting point
		PartClamp := TRUE;
		IF McStop.Done THEN
			bAllowToDepartAfterHeatUp := FALSE;
			fbTON_WorkStepTime_Alg(IN:= FALSE, PT:= REAL_TO_TIME(stTestParams.rHeatingUpTime_s*1000));
			iWorkStep_Alghorithm := 33;
		ELSIF McStop.Error THEN
			bMeltingActive:= FALSE;
			mNewEvent(nEvent:= nHP_Axis_ErrorList.MotionFB_Error, ErrorCode := McStop.ErrorID);
		END_IF
		IF iWorkStep_Alghorithm <> 32 THEN 
			McStop.Execute := FALSE; 
			fbTON_WorkStepTime_Alg(IN:= FALSE); 
		END_IF
	
	33:		// Heat up part  - no movement
		fbTON_WorkStepTime_Alg(IN:= TRUE);
		IF fbTON_WorkStepTime_Alg.Q THEN
			lrHeatUpPos_mm := ActualPosition;
			GVL_Aircom.fbFormatString(sFormat := 'Nagrzewanie zakonczone, pozycja HeatUp %.3f[mm])',
						 arg1:= F_LREAL(McReadActualPosition.Position)); 
				mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
			iWorkStep_Alghorithm := 35;
		END_IF
		IF iWorkStep_Alghorithm <> 33 THEN fbTON_WorkStepTime_Alg(IN:= FALSE); END_IF
		
	35:		// Part heated up
		IF bAllowToDepartAfterHeatUp THEN
			rAdhesionMaxForce := 0;
			IF stTestParams.rAdhesionForceLimit_N > 0.1 THEN
				iWorkStep_Alghorithm := 40;
			ELSE 
				iWorkStep_Alghorithm := 45;
			END_IF
			
		END_IF
		
	40:		// Departure from Heated Plate
		fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#4S);
		IF fbTON_WorkStepTime_Alg.Q THEN
			McMoveVelocity.Execute := FALSE;
			McStop.Execute := TRUE;
			mNewEvent(nEvent:= nHP_Axis_ErrorList.DepartureFromHeatedPlateTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
		ELSIF McMoveVelocity.Execute THEN
			rAdhesionMaxForce := MIN(rAdhesionMaxForce, ActualForce);
			IF ActualPosition < (lrHeatUpPos_mm-1.0) AND ABS(ActualForce) < stTestParams.rAdhesionForceLimit_N THEN			
				McMoveVelocity.Execute := FALSE;
				iWorkStep_Alghorithm := 45;
			ELSIF ABS(ActualForce) > (1.05*stTestParams.rAdhesionForceLimit_N) AND McMoveVelocity.Velocity > 0.0 THEN
				McMoveVelocity(Axis := stInOuts.stAxis_Data, Execute := FALSE);
				McMoveVelocity.Execute := TRUE;
				McMoveVelocity.Velocity := 0;
			ELSIF ABS(ActualForce) < (0.95*stTestParams.rAdhesionForceLimit_N) AND McMoveVelocity.Velocity <= 0.1 THEN
				McMoveVelocity(Axis := stInOuts.stAxis_Data, Execute := FALSE);
				McMoveVelocity.Execute := TRUE;
				McMoveVelocity.Velocity := 3*stSettings.rSlowSpeed_mm_s;
			END_IF
		ELSE
			McMoveVelocity.Direction := MC_Direction.MC_Negative_Direction;
			McMoveVelocity.Velocity := 3*stSettings.rSlowSpeed_mm_s;
			McMoveVelocity.Execute := TRUE;
		END_IF
		IF iWorkStep_Alghorithm <> 40 THEN fbTON_WorkStepTime_Alg(IN:= FALSE); END_IF
		
	45:		// After adjustment and depart from heated plate done go to safe pos to allow to hide heated plate
		fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#3S);
		bDetectCollision_Active S= ActualPosition < (lrHeatUpPos_mm-2.0);
		rAdhesionMaxForce := MIN(rAdhesionMaxForce, ActualForce);
		IF mMoveFastToPresetPos(nSetPos := nHP_Axis_PresetPositions.SafeHpMove_Pos,bError => bAlg_Error) 
			 	AND_THEN NOT bAlg_Error THEN
			GVL_Aircom.fbFormatString(sFormat := 'Odjazd od plyty zakonczony, max adhezja %.1f[N])',
					 arg1:= F_REAL(rAdhesionMaxForce)); 
			mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
			iWorkStep_Alghorithm := 50;
		ELSIF fbTON_WorkStepTime_Alg.Q OR bAlg_Error THEN
			mNewEvent(nEvent:= nHP_Axis_ErrorList.MotionWorkStepTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
		END_IF
		IF iWorkStep_Alghorithm <> 45 THEN fbTON_WorkStepTime_Alg(IN:= FALSE); END_IF
		
	50:		// Wait for hide Heat plate to home position and go to desired connecting position
		bDetectCollision_Active := TRUE;
		bConnectingActive:= FALSE;
		IF bHP_InHomePos THEN	
			fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#3S);
			IF stTestParams.nConnectingMode = nHP_Axis_ConnectionModes.None THEN		// Jedź na pozycję łączenia czyli tam gdzie zakończyło się nagrzewanie i czekaj na zakończenie operacji
				IF mMoveFastToPresetPos(nSetPos := nHP_Axis_PresetPositions.Connection_Pos, bError => bAlg_Error)
						AND_THEN NOT bAlg_Error THEN
					GVL_Aircom.fbFormatString(sFormat := 'Os w punkcie laczenia (%.3f[mm])- koniec cyklu osi',
							 arg1:= F_LREAL(McReadActualPosition.Position)); 
					mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
					iWorkStep_Alghorithm := 70;
				END_IF
			ELSE	// Jedć na pozycję przed pkt. zgrzewania czyli pozycja zakończenia nagrzewania + grubość płyty - Xmm (np. 1mm)
				IF mMoveFastToPresetPos(nSetPos := nHP_Axis_PresetPositions.PreConnection_Pos, bError => bAlg_Error) 
						AND_THEN NOT bAlg_Error THEN
					GVL_Aircom.fbFormatString(sFormat := 'Os w punkcie PreLaczenia %.3f[mm]',
							 arg1:= F_LREAL(McReadActualPosition.Position)); 
					mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
					bStartConnecting := FALSE;
					iWorkStep_Alghorithm := 55;
				END_IF
			END_IF
			IF fbTON_WorkStepTime_Alg.Q OR bAlg_Error THEN
				mNewEvent(nEvent:= nHP_Axis_ErrorList.MotionWorkStepTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
			END_IF
		END_IF
		IF iWorkStep_Alghorithm <> 50 THEN 
			bDetectCollision_Active := FALSE;
			fbTON_WorkStepTime_Alg(IN:= FALSE); 
		END_IF
		
	55:		// Connecting- looking for contact point
		IF bStartConnecting THEN
			fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#5S);
			IF McMoveVelocity.Execute THEN
				IF ActualForce >= stTestParams.rConContactDetecForce_N THEN
					lrConnectionContactPoint_mm := ActualPosition;
					lrConnectionContactPointDif_mm := lrConnectionContactPoint_mm - lrHeatUpPos_mm;
					GVL_Aircom.fbFormatString(sFormat := 'Laczenie- wykryto kontakt czesci. Roznica wzgl obliczonego %.3f[mm]',
							arg1:= F_LREAL(lrConnectionContactPointDif_mm)); 
					mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
					fbTON_WorkStepTime_Alg(IN:= FALSE);
					iWorkStep_Alghorithm := 56;
				ELSIF ActualPosition > (lrHeatUpPos_mm + lrHeatPlateHeight_mm+5.0) THEN
					mNewEvent(nEvent:= nHP_Axis_ErrorList.ConnectionTouchPointDetectTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
				END_IF
			ELSE
				McMoveVelocity.Direction := MC_Direction.MC_Positive_Direction;
				McMoveVelocity.Velocity := stSettings.rSlowSpeed_mm_s;
				McMoveVelocity.Execute := TRUE;
			END_IF		
			IF fbTON_WorkStepTime_Alg.Q THEN
				mNewEvent(nEvent:= nHP_Axis_ErrorList.ConnectionTouchPointDetectTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
			END_IF
		END_IF
		IF iWorkStep_Alghorithm <> 55 THEN fbTON_WorkStepTime_Alg(IN:= FALSE); END_IF	
			
	56:		// Connecting
		fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= REAL_TO_TIME(stTestParams.rConnectingTimeout_s*1000));
		bConnectingActive:= TRUE;
		fbMc_ForcePID.ACTUAL := ActualForce;	// rExternalForce_N;
		fbMc_ForcePID.SET_POINT := stTestParams.rConnectingForce_N; 
		bPID_ForceRegulation := FALSE;
		bConnectionMinForceReached S= ActualForce > stTestParams.rConnectingMinForce_N;
		IF rConnectingMaxForce < ActualForce THEN
 			rConnectingMaxForce := ActualForce;
		END_IF
		CASE stTestParams.nConnectingMode OF
			nHP_Axis_ConnectionModes.FitByDRM:
				IF ActualPosition >= (lrConnectionContactPoint_mm + stTestParams.lrConnectingDistance_mm) THEN
					IF stTestParams.rConnectingMinForce_N > 0 AND NOT bConnectionMinForceReached THEN	// Wykrywanie siły włącozne oraz siła nie osiągnięta
						GVL_Aircom.fbFormatString(sFormat := 'Laczenie DRM- nie osiagnieto min sily laczenia %.1f[N] (max. sila laczenia %.1f[N])',
								arg1:= F_REAL(stTestParams.rConnectingMinForce_N),
								arg2:= F_REAL(rConnectingMaxForce));
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
						mNewEvent(nEvent:= nHP_Axis_ErrorList.ConnectionNoMinForceReached, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
					ELSE
						GVL_Aircom.fbFormatString(sFormat := 'Laczenie DRM- osiagnieto droge laczenia %.3f[mm], poz. %.3f[mm], max sila %.1f[N]',
								arg1:= F_LREAL(stTestParams.lrConnectingDistance_mm),
								arg2:= F_LREAL(McReadActualPosition.Position),
								arg3:= F_REAL(rConnectingMaxForce));
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
						iWorkStep_Alghorithm := 57;
					END_IF
				END_IF
				
			nHP_Axis_ConnectionModes.FitByABS:
//				IF ActualPosition >= (lrBasePos_mm + lrHeatPlateHeight_mm + stTestParams.lrConnectingDistance_mm) THEN
				IF ActualPosition >= (lrHeatUpPos_mm + lrHeatPlateHeight_mm + stTestParams.lrConnectingDistance_mm) THEN
					IF stTestParams.rConnectingMinForce_N > 0 AND NOT bConnectionMinForceReached THEN	// Wykrywanie siły włącozne oraz siła nie osiągnięta
						GVL_Aircom.fbFormatString(sFormat := 'Laczenie ABS- nie osiagnieto min sily laczenia %.1f[N] (max. sila laczenia %.1f[N])',
								arg1:= F_REAL(stTestParams.rConnectingMinForce_N),
								arg2:= F_REAL(rConnectingMaxForce));
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
						mNewEvent(nEvent:= nHP_Axis_ErrorList.ConnectionNoMinForceReached, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
					ELSE
						lrTmp:= ActualPosition - lrConnectionContactPoint_mm;
						GVL_Aircom.fbFormatString(sFormat := 'Laczenie ABS- osiagnieto droge laczenia, poz. %.3f[mm], max sila %.1f[N], droga %.2f[mm]',
								arg1:= F_LREAL(McReadActualPosition.Position),
								arg2:= F_REAL(rConnectingMaxForce),
								arg3:= F_LREAL(lrTmp),);
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
						iWorkStep_Alghorithm := 57;
					END_IF 
				END_IF		
			
			nHP_Axis_ConnectionModes.FitByForce:
				IF ActualForce > stTestParams.rConnectingForce_N THEN
					IF ActualPosition < (lrConnectionContactPoint_mm + stTestParams.lrConnectingDistance_mm) THEN
						lrTmp:= ActualPosition - lrConnectionContactPoint_mm;
						GVL_Aircom.fbFormatString(sFormat := 'Laczenie na sile- nie osiagnieto min drogi laczenia (aktualna/zadana %.3f/%.3f[mm]',
								arg1:= F_LREAL(lrTmp),
								arg2:= F_LREAL(stTestParams.lrConnectingDistance_mm));
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
						mNewEvent(nEvent:= nHP_Axis_ErrorList.ConnectionNoMinDistanceReached, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
					ELSE	
						lrTmp:= ActualPosition - lrConnectionContactPoint_mm;
						GVL_Aircom.fbFormatString(sFormat := 'Laczenie na sile- pozycja %.3f[mm], droga %.3f[mm]',
								arg1:= F_LREAL(McReadActualPosition.Position),
								arg2:= F_LREAL(lrTmp));
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
						iWorkStep_Alghorithm := 57;
					END_IF 
				END_IF		
							
		END_CASE
		IF fbTON_WorkStepTime_Alg.Q THEN
			mNewEvent(nEvent:= nHP_Axis_ErrorList.ConnectionTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
		END_IF
		IF iWorkStep_Alghorithm <> 56 THEN 
			bConnectingActive:= FALSE;
			McMoveVelocity.Execute := FALSE;
			McStop.Execute := TRUE;
			fbTON_WorkStepTime_Alg(IN:= FALSE); 
		END_IF
			
	57:		// Connetion ended - cool down
		IF McStop.Done THEN
			McStop.Execute := FALSE; 
			fbTON_WorkStepTime_Alg(IN:= FALSE);
			iWorkStep_Alghorithm := 60;
		ELSIF McStop.Error THEN
			McStop.Execute := FALSE; 
			mNewEvent(nEvent:= nHP_Axis_ErrorList.MotionFB_Error, ErrorCode := McStop.ErrorID);
		END_IF
		
	60:		// Cooling down
		fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= REAL_TO_TIME(stTestParams.rCoolingDownTime_s*1000));
		IF fbTON_WorkStepTime_Alg.Q THEN		// Parts connected
			fbTON_WorkStepTime_Alg(IN:= FALSE);
			iWorkStep_Alghorithm := 70;
		END_IF
		
	70:		// Connection ended
		IF bWeldResultReaded THEN
			iWorkStep_Alghorithm := 0;	
		END_IF
		
	90:		// Error occurr
		fbTON_WorkStepTime_Alg(IN:= FALSE);
		
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Property Name="ActualForce" Id="{c0837df3-2618-4d7f-88e1-eb848835d8ec}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY ActualForce : REAL]]></Declaration>
      <Get Name="Get" Id="{efab2def-2537-4746-b0ec-4deb2d35084e}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF NOT stInOuts.stLoadCell_Data.wStatus.1 AND NOT stInOuts.stLoadCell_Data.wStatus.3 AND NOT stInOuts.stLoadCell_Data.wStatus.6 THEN
	ActualForce := fbForceFilter.rOut;
ELSE
	ActualForce := -1;
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="ActualPosition" Id="{939281a9-5298-4d87-9efc-b3472fb418fd}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY ActualPosition : LREAL]]></Declaration>
      <Get Name="Get" Id="{b34599e6-1b8c-453a-ada2-408118002703}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF McReadActualPosition.Valid AND IsHomed THEN		
	ActualPosition := McReadActualPosition.Position;
ELSE
	ActualPosition := -1;
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="ActualPresetPosition" Id="{7eb33f1a-b165-4a36-9299-d759f82bb5b3}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY ActualPresetPosition : nHP_Axis_PresetPositions]]></Declaration>
      <Get Name="Get" Id="{38cc0990-ea26-4ab7-a135-cdd777594e24}">
        <Declaration><![CDATA[VAR
	rHist:REAL;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[rHist := 0.5;
IF ActualPosition < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.MIN_Pos;

ELSIF ActualPosition > (stSettings.lrMax_Pos - rHist) THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.MAX_Pos;

ELSIF ABS(ActualPosition-stSettings.lrService_Pos_mm) < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.Service_Pos;

ELSIF ABS(ActualPosition-stTestParams.lrSafeHpMovementPos_mm) < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.SafeHpMove_Pos;

ELSIF ABS(ActualPosition-stTestParams.lrPartLoadPosition_mm) < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.PartLoad_Pos;

ELSIF ABS(ActualPosition-(lrBasePos_mm - stTestParams.lrPreBaseOffset_mm)) < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.PreBase_Pos;

ELSIF ABS(ActualPosition-(lrHeatUpPos_mm - stTestParams.lrPreConnectingOffset_mm)) < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.PreConnection_Pos;

ELSIF ABS(ActualPosition-lrHeatUpPos_mm + lrHeatPlateHeight_mm) < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.Connection_Pos;

ELSIF ABS(ActualPosition-lrMarkingPos_mm) < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.Marking_Pos;
	
ELSE
	ActualPresetPosition := nHP_Axis_PresetPositions.UnDefined;
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="ActualVelocity" Id="{a2435536-435a-401c-a571-00d83d904b9c}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY ActualVelocity : LREAL]]></Declaration>
      <Get Name="Get" Id="{e9805a1f-b053-47bb-99dc-86fc34f252fb}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF McReadActualVelocity.Valid THEN
	ActualVelocity := McReadActualVelocity.ActualVelocity;
ELSE
	ActualVelocity := -1;
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Enabled" Id="{feb01cb3-4d57-40bb-b5c5-144e05623078}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY Enabled : BOOL]]></Declaration>
      <Get Name="Get" Id="{4c86d9e2-7361-4d16-b33b-3b43535ea8ea}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Enabled:= McPower.Status;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{795e300e-6251-446e-a05f-bcd893d2f7b6}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF Enabled AND bSTO_Signal THEN
	bEnableMotion := TRUE;	
	McPower.Enable := TRUE;
	ACT_AxisFBs();
ELSE
	IF IsMoving THEN
		mNewEvent( nEvent := nHP_Axis_ErrorList.ProgramError ,ErrorCode:= INT_TO_UDINT(iWorkStep_Axis));	
		bEnableMotion := FALSE;
	ELSE
		bEnableMotion := FALSE;	
		McPower.Enable := FALSE;
		ACT_AxisFBs();
		iWorkStep_Axis := 5;
	END_IF
END_IF]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="InSetPos_ConnPos" Id="{d5d17399-7c22-4c57-889b-886c0b4a66db}" FolderPath="Properties\InPos\">
      <Declaration><![CDATA[PROPERTY InSetPos_ConnPos : BOOL]]></Declaration>
      <Get Name="Get" Id="{fb93b483-39a3-4cd9-a4af-729ac1e64d11}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[InSetPos_ConnPos := ABS(ActualPosition-(lrHeatUpPos_mm + lrHeatPlateHeight_mm)) < 0.5 AND lrHeatUpPos_mm > stTestParams.lrSafeHpMovementPos_mm AND lrHeatUpPos_mm > 10.0;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="InSetPos_MarkingPos" Id="{c04ff599-bc44-4039-b6e6-cf4d3997d018}" FolderPath="Properties\InPos\">
      <Declaration><![CDATA[PROPERTY InSetPos_MarkingPos : BOOL]]></Declaration>
      <Get Name="Get" Id="{ce345075-cb84-4a9f-984c-3c66103c2632}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[InSetPos_MarkingPos := ABS(ActualPosition-lrMarkingPos_mm) < 0.5;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="InSetPos_MaxPos" Id="{cea1cbda-ab04-42b4-83a6-f6841abfb9b2}" FolderPath="Properties\InPos\">
      <Declaration><![CDATA[PROPERTY InSetPos_MaxPos : BOOL]]></Declaration>
      <Get Name="Get" Id="{8028c1f1-196c-4506-afdc-d028efc73047}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[InSetPos_MaxPos := ABS(ActualPosition- stSettings.lrMax_Pos) < 0.5;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="InSetPos_MinPos" Id="{0e857f5f-bcc2-4778-93f6-75adb8c83146}" FolderPath="Properties\InPos\">
      <Declaration><![CDATA[PROPERTY InSetPos_MinPos : BOOL]]></Declaration>
      <Get Name="Get" Id="{1da567f6-ed23-42c1-a5e6-de822ec64269}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[InSetPos_MinPos := ABS(ActualPosition) < 0.5;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="InSetPos_PartLoad" Id="{73741ba1-b868-4cb2-ab2f-16208aea97e2}" FolderPath="Properties\InPos\">
      <Declaration><![CDATA[PROPERTY InSetPos_PartLoad : BOOL]]></Declaration>
      <Get Name="Get" Id="{d1f4352f-2f8b-4b25-a83b-d9d92ddfe7f3}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[InSetPos_PartLoad := ABS(ActualPosition-stTestParams.lrPartLoadPosition_mm) < 0.5;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="InSetPos_SafeHpMove" Id="{4fe17158-839b-43fc-b952-2cd40a00bbb2}" FolderPath="Properties\InPos\">
      <Declaration><![CDATA[PROPERTY InSetPos_SafeHpMove : BOOL]]></Declaration>
      <Get Name="Get" Id="{e9c5cdb9-f40a-4b51-a631-88fe5a676031}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[InSetPos_SafeHpMove := ABS(ActualPosition-stTestParams.lrSafeHpMovementPos_mm) < 0.5;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsCalibrated" Id="{5d0b50bb-0368-47e9-ad42-2ad78627cc67}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY IsCalibrated : BOOL]]></Declaration>
      <Get Name="Get" Id="{d3a52861-5245-410c-88e8-c224741b394f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsCalibrated := lrBasePos_mm > 1.0;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{a82a9241-e411-4183-b7fd-b331e43f47e5}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF NOT IsCalibrated THEN
	lrBasePos_mm := 0.0;
END_IF]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="IsErrorActive" Id="{cc3158b7-3848-40f4-8e4f-fe3e71527d49}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY IsErrorActive : BOOL]]></Declaration>
      <Get Name="Get" Id="{ad87d114-24b8-4ede-b6b5-ecdab228e5f7}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsErrorActive := stInOuts.stAxis_Data.Status.Error OR iWorkStep_Axis >= 90 OR iWorkStep_Alghorithm >= 90;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsHomed" Id="{275b6bcf-ae89-4811-9555-73f23ac13931}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY IsHomed : BOOL]]></Declaration>
      <Get Name="Get" Id="{4953bd21-581f-4185-b629-3385add46705}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsHomed := stInOuts.stAxis_Data.Status.Homed;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsMoving" Id="{5c90056a-a513-422e-ae84-778d1f5a4a1f}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY IsMoving : BOOL]]></Declaration>
      <Get Name="Get" Id="{16529d55-7854-439b-9396-bf24a4deb775}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsMoving := stInOuts.stAxis_Data.Status.Moving;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsReady" Id="{a8a03168-0996-4eba-abd0-adf0a88c9231}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY IsReady : BOOL]]></Declaration>
      <Get Name="Get" Id="{522d496f-8289-4c13-afa2-4f17aa9e7e17}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsReady := stInOuts.stAxis_Data.Status.Operational AND NOT stInOuts.stAxis_Data.Status.Error AND McPower.Status AND iWorkStep_Axis = 10;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsReadyForOperation" Id="{49d6d946-4a5e-4c18-8c14-061a82bebba6}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY IsReadyForOperation : BOOL]]></Declaration>
      <Get Name="Get" Id="{b38286b5-1aa8-4ae1-9f47-972022322773}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsReadyForOperation := IsReady AND iWorkStep_Alghorithm = 10;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsSafeToMoveHP" Id="{71afc8f9-88e3-472e-9ba6-748d7ea243d9}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY IsSafeToMoveHP : BOOL]]></Declaration>
      <Get Name="Get" Id="{0de9a55e-4813-48d0-af23-fe9c50b2fd2b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsSafeToMoveHP := IsHomed AND ActualPosition <= (stTestParams.lrSafeHpMovementPos_mm+0.2);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="mAddTimeStat" Id="{3d69b4aa-bbd7-4616-b364-faae95222c53}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mAddTimeStat : BOOL
VAR_INPUT
	sText 		: STRING(255);
END_VAR
VAR
	sTextTmp	: STRING(255);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF I_TimeTableRef <> 0 THEN
	CONCAT2(pSrcString1 := ADR(sTTRowPreambule), pSrcString2 := ADR(sText), pDstString := ADR(sTextTmp), nDstSize := SIZEOF(sTextTmp));
	I_TimeTableRef.mPushText(sText := sTextTmp);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="ManualMode" Id="{4836167c-65c5-4803-a4e4-e8d95ae552b2}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY ManualMode : BOOL]]></Declaration>
      <Get Name="Get" Id="{68c5c285-ea68-4154-a15f-9740c8304880}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[ManualMode := iWorkStep_Axis = 15;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{9e127a9b-8352-40e4-8ec8-6c95742d3059}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF ManualMode AND NOT IsErrorActive THEN		
	bEnableMotion := TRUE;	
	McPower.Enable := TRUE;
	ACT_AxisFBs();
	IF Enabled THEN
		iWorkStep_Axis := 15;
	END_IF	
ELSIF NOT ManualMode THEN
	IF iWorkStep_Axis = 15 THEN
		McJog(Axis:= stInOuts.stAxis_Data, JogForward := FALSE, JogBackwards := FALSE);
		bEnableMotion := TRUE;	
		McPower.Enable := FALSE;
		McBrakeCtrl.Execute := TRUE;
		McBrakeCtrl.Mode := E_BrakeMode.eBrakeMode_Automatic;
		ACT_AxisFBs();
		iWorkStep_Axis := 5;		
	END_IF
END_IF]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="mCalibrateAxis" Id="{231e62d2-564e-4dd4-a8e2-0314b4aa13e3}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mCalibrateAxis : BOOL
VAR_INPUT
	bPartCalib	: BOOL;
END_VAR
VAR_OUTPUT
	bBusy		: BOOL;
	bError		: BOOL;
	udiErrorId	: UDINT;
	lrContactPos: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsReady THEN
	lrCalibrationPoint_mm := 0.0;
	iWorkStep_Axis := 40;
	bBusy := TRUE;	
ELSIF iWorkStep_Axis >= 40 AND iWorkStep_Axis < 44 THEN
	bBusy := TRUE;
	bPartBaseCalibration := bPartCalib;
	lrContactPos := lrCalibrationPoint_mm;
ELSIF iWorkStep_Axis = 44 THEN
	bBusy := FALSE;
	lrContactPos := lrCalibrationPoint_mm;
	mCalibrateAxis := bDoneReceived := TRUE;
	bError := lrCalibrationPoint_mm < 1.0;
ELSE
	mCalibrateAxis := TRUE;
	bError := TRUE;
	IF nActEvent <> 0 THEN
		udiErrorId := nActEvent;
	ELSIF udiActErrorCode <> 0 THEN
		udiErrorId := udiActErrorCode;
	ELSE	
		udiErrorId := INT_TO_UINT(iWorkStep_Axis);		
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mGoToSafeState" Id="{5cc91b60-68b8-45e8-bf3c-df422442100e}" FolderPath="Methods\">
      <Declaration><![CDATA[// Method for external force axis to move to safe position in desired time
METHOD mGoToSafeState : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF iWorkStep_Axis < 90 THEN
	IF NOT bOnlySafeState THEN
		McHome.Execute := McStop.Execute := FALSE;
		McJog.JogForward := McJog.JogBackwards := McMoveAbs.Execute := McMoveRel.Execute := McMoveVelocity.Execute := FALSE; 
		ACT_AxisFBs();
		iWorkStep_Axis := 90;
		iWorkStep_Alghorithm := 0;
		bOnlySafeState := TRUE;
	ELSIF bOnlySafeState THEN
		mGoToSafeState := NOT Enabled;
	END_IF	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mHomeAxis" Id="{329c0272-1d60-496a-a5da-146d7cf386e8}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mHomeAxis : BOOL
VAR_INPUT
END_VAR
VAR_OUTPUT
	bBusy		: BOOL;
	bError		: BOOL;
	udiErrorId	: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsReady THEN
	iWorkStep_Axis := 20;
	bBusy := TRUE;
ELSIF iWorkStep_Axis >= 20 AND iWorkStep_Axis <= 24 THEN
	bBusy := McHome.Busy;
	mHomeAxis := bDoneReceived := McHome.Done;
	bError := McHome.Error;
	udiErrorId := McHome.ErrorID;
ELSE
	mHomeAxis := TRUE;
	bError := TRUE;
	udiErrorId := INT_TO_UINT(iWorkStep_Axis);	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mManualMove" Id="{e1232645-9268-4da7-87b0-17e3e1e9be4b}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mManualMove : BOOL
VAR_INPUT
	bGoUp		: BOOL;
	bGoDown		: BOOL;
	bSlow		: BOOL;
	bFast		: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF bGoUp OR bGoDown THEN
	bHMI_Plus := bHMI_Minus := FALSE;
	fbTON_ManualJogReset(IN:= FALSE);	
END_IF
fbRTRIG_ManGoForward(CLK:= bGoUp OR bHMI_Plus);
bManModeForceMax R= fbRTRIG_ManGoForward.Q; 
bManModeForceMax S= (ActualForce > stSettings.rManualModeMaxForceAtSlow AND stSettings.rManualModeMaxForceAtSlow > 0.0);
bManModeMoveSlower S= stSettings.rManualModeMaxForceAtSlow > 0 AND bSlow AND ActualForce >= 5;
bManModeMoveSlower R= ActualForce < 4 OR stSettings.rManualModeMaxForceAtSlow <= 0.1 OR NOT bSlow;
fbRTRIG_ManMoveSwitchSlower(CLK:= bManModeMoveSlower);
IF fbRTRIG_ManMoveSwitchSlower.Q THEN
		McJog(Axis := stInOuts.stAxis_Data, JogBackwards := FALSE, JogForward := FALSE);	
END_IF

IF bSlow THEN
	IF bManModeMoveSlower  THEN
		McJog.Velocity := LIMIT(0.1, stSettings.rSlowSpeed_mm_s/4, 4);
	ELSE
		McJog.Velocity := LIMIT(0.5, stSettings.rSlowSpeed_mm_s, 4);		
	END_IF
	McJog.JogForward := (bHMI_Plus OR bGoUp) AND NOT bGoDown AND NOT bManModeForceMax;
	McJog.JogBackwards := (bHMI_Minus OR bGoDown) AND NOT bGoUp;
ELSIF bFast THEN
	McJog.Velocity := 20;
	McJog.JogForward := bGoUp AND NOT bGoDown;
	McJog.JogBackwards := bGoDown AND NOT bGoUp;
ELSE	
	McJog.Velocity := LIMIT(0.1, stSettings.rSlowSpeed_mm_s/2, 4);
	McJog.JogForward := bHMI_Plus AND NOT bHMI_Minus AND NOT bManModeForceMax;
	McJog.JogBackwards := bHMI_Minus AND NOT bHMI_Plus;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="mMoveFastToPresetPos" Id="{47c3eace-4497-4a5f-8e2b-815386f988be}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mMoveFastToPresetPos : BOOL
VAR_INPUT
	nSetPos		: nHP_Axis_PresetPositions;
END_VAR
VAR_OUTPUT
	bBusy		: BOOL;
	bError		: BOOL;
	udiErrorId	: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsReady THEN
	CASE nSetPos OF
		nHP_Axis_PresetPositions.MIN_Pos:	McMoveAbs.Position := 0.0;
		nHP_Axis_PresetPositions.MAX_Pos:	McMoveAbs.Position := stSettings.lrMax_Pos;
		nHP_Axis_PresetPositions.Service_Pos:	McMoveAbs.Position := stSettings.lrService_Pos_mm;
		nHP_Axis_PresetPositions.SafeHpMove_Pos:	McMoveAbs.Position := stTestParams.lrSafeHpMovementPos_mm;
		nHP_Axis_PresetPositions.PartLoad_Pos:	McMoveAbs.Position := stTestParams.lrPartLoadPosition_mm;
		nHP_Axis_PresetPositions.PreBase_Pos:	McMoveAbs.Position := lrBasePos_mm - stTestParams.lrPreBaseOffset_mm;
		nHP_Axis_PresetPositions.PreConnection_Pos:		McMoveAbs.Position := lrHeatUpPos_mm - stTestParams.lrPreConnectingOffset_mm;
		nHP_Axis_PresetPositions.Connection_Pos:	McMoveAbs.Position := lrHeatUpPos_mm + lrHeatPlateHeight_mm;
		nHP_Axis_PresetPositions.Marking_Pos:	McMoveAbs.Position := lrMarkingPos_mm;
	END_CASE
	 
	IF McMoveAbs.Position >= 1.0 OR nSetPos = nHP_Axis_PresetPositions.MIN_Pos  THEN
		McMoveAbs.Velocity := LIMIT(10, stSettings.rFastSpeed_mm_s, 320);
		iWorkStep_Axis := 30;
		bBusy := TRUE;
	ELSE
		mMoveFastToPresetPos := bError := TRUE;
	END_IF
	
ELSIF iWorkStep_Axis >= 30 AND iWorkStep_Axis <= 34 THEN
	bBusy := McMoveAbs.Busy;
	mMoveFastToPresetPos := bDoneReceived := McMoveAbs.Done;
	bError := McMoveAbs.Error;
	udiErrorId := McMoveAbs.ErrorID;
ELSE
	mMoveFastToPresetPos := TRUE;
	bError := TRUE;
	udiErrorId := INT_TO_UINT(iWorkStep_Axis);	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mMoveToAbsPos" Id="{cad259dd-92fb-4a66-836e-0eb8895d7552}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mMoveToAbsPos : BOOL
VAR_INPUT
	lrSetPos		: LREAL;
	bFastSpeed		: BOOL;
END_VAR
VAR_OUTPUT
	bBusy		: BOOL;
	bError		: BOOL;
	udiErrorId	: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsReady THEN
	McMoveAbs.Position := LIMIT(0.0, lrSetPos, stSettings.lrMax_Pos);
	IF bFastSpeed THEN
		McMoveAbs.Velocity := LIMIT(10, stSettings.rFastSpeed_mm_s, 320);
	ELSE
		McMoveAbs.Velocity := LIMIT(0.5, stSettings.rSlowSpeed_mm_s, 20);
	END_IF
	iWorkStep_Axis := 30;
	bBusy := TRUE;	
ELSIF iWorkStep_Axis >= 30 AND iWorkStep_Axis <= 34 THEN
	bBusy := McMoveAbs.Busy;
	mMoveToAbsPos := bDoneReceived := McMoveAbs.Done;
	bError := McMoveAbs.Error;
	udiErrorId := McMoveAbs.ErrorID;
ELSE
	mMoveToAbsPos := TRUE;
	bError := TRUE;
	udiErrorId := INT_TO_UINT(iWorkStep_Axis);	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mNewEvent" Id="{372cf8ca-7d03-41e3-8c64-8ace476ef0ce}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD INTERNAL mNewEvent : BOOL
VAR_INPUT
	nEvent: nHP_Axis_ErrorList;
	ErrorCode: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
MEMMOVE(srcAddr:= ADR(astErrorHistory[1]), destAddr := ADR(astErrorHistory[2]), n:= 9* SIZEOF(astErrorHistory[1]));
astErrorHistory[1].tTimeStamp := TIME();
astErrorHistory[1].sDescription := TO_STRING(nEvent);
astErrorHistory[1].iWorkStep1 := iWorkStep_Axis;
astErrorHistory[1].iWorkStep2 := iWorkStep_Alghorithm;
astErrorHistory[1].udiErrorCode := ErrorCode;

iWorkStep_Alghorithm := iWorkStep_Axis := 90;
bAlg_Error := TRUE;
udiErrorCodeToRead := udiAlg_ErrorId := nEvent;
nActEvent := nEvent;
udiActErrorCode:= ErrorCode;
fbTON_WorkStepTime_Alg(IN := FALSE);
IF ErrorCode <> 0 THEN
	udiMcErrorToRead := udiMcError:= ErrorCode;
END_IF


bMeltingActive := bConnectingActive := bDetectCollision_Active := FALSE;
McReset.Execute := McHome.Execute := McStop.Execute := FALSE;
McJog.JogForward := McJog.JogBackwards := McMoveAbs.Execute := McMoveRel.Execute := McMoveVelocity.Execute := FALSE;
ACT_AxisFBs();]]></ST>
      </Implementation>
    </Method>
    <Method Name="mReadError" Id="{33973b72-ad54-4ee9-a864-9ed53445a967}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mReadError : BOOL
VAR_OUTPUT
	udiErrorID		: UDINT;
	udiMcErrorID	: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF udiErrorCodeToRead <> 0 THEN
	mReadError:= TRUE;
	udiErrorID := udiErrorCodeToRead;
	udiErrorCodeToRead := 0;
END_IF
IF udiMcErrorToRead <> 0 THEN
	mReadError:= TRUE;
	udiMcErrorID := udiMcErrorToRead;
	udiMcErrorToRead := 0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="mReset" Id="{07148389-af75-4b33-97b0-d61583a3aed9}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mReset : BOOL
VAR_OUTPUT
	bBusy		: BOOL;
	bError		: BOOL;
	udiErrorId	: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF iWorkStep_Axis = 94 THEN
	iWorkStep_Axis := 95;
	bBusy := TRUE;
ELSIF iWorkStep_Axis = 95 THEN
	bBusy := TRUE;
ELSIF iWorkStep_Axis = 96 THEN
	iWorkStep_Axis := 5;
	mReset := TRUE;
ELSIF iWorkStep_Axis = 97 THEN
	mReset := TRUE;
	bError := TRUE;
	udiErrorId := McReset.ErrorID;
ELSIF iWorkStep_Axis = 5 OR iWorkStep_Axis = 10 THEN
	mReset := TRUE; 
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="mStartWelding" Id="{327ddbd1-c6bc-4b3a-acd2-6e64c796add8}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mStartWelding : BOOL
VAR_INPUT
	bHP_WorkPos				: BOOL;
	bHP_HomePos				: BOOL;
	rAdjDelay_ms			: REAL;
	bDepartureAfterHeatUp 	: BOOL;
	bConnectPermission 		: BOOL;
END_VAR
VAR_OUTPUT
	bBusy					: BOOL;
	bError					: BOOL;
	udiErrorId				: UDINT;
	bOpenHP					: BOOL;
	rAdjTime_ms				: REAL;
	bPartHeatedUp			: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF iWorkStep_Alghorithm >= 15 AND iWorkStep_Alghorithm < 90 THEN
	bHP_InWorkPos := bHP_WorkPos;
	bHP_InHomePos := bHP_HomePos;
	rMeltingDelay_ms := rAdjDelay_ms;
	bAllowToDepartAfterHeatUp := bDepartureAfterHeatUp;
	bStartConnecting := bConnectPermission;
	bOpenHP := iWorkStep_Alghorithm >= 16 AND iWorkStep_Alghorithm < 50;
	rAdjTime_ms := rMeltingTime;
	bPartHeatedUp := iWorkStep_Alghorithm >= 35;
	bBusy := TRUE;
	bError := bAlg_Error;
	udiErrorId := udiAlg_ErrorId;
	bWeldResultReaded:= FALSE;
	IF iWorkStep_Alghorithm = 70 THEN
		mStartWelding := TRUE;
		bWeldResultReaded:= TRUE;
	END_IF
ELSIF IsReady AND iWorkStep_Alghorithm = 10 THEN
	iWorkStep_Alghorithm := 15;
	bBusy := TRUE;			  
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="PartClamp" Id="{048917b4-daa6-44b0-8758-ce30e97f283e}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY PartClamp : BOOL]]></Declaration>
      <Get Name="Get" Id="{39cae284-a7f9-4b94-99ac-1e688f2e3b5c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[PartClamp := stInOuts.bQ_PartLockPiston;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{3ee52515-20d6-4f0d-9330-f5aa132343b1}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[stInOuts.bQ_PartLockPiston := PartClamp;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="PartSensorState" Id="{6754fb23-fe1d-4a1a-9a14-7af2e7131ff1}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY PartSensorState : BOOL]]></Declaration>
      <Get Name="Get" Id="{07c91ff2-0990-4af0-9c44-1a81ee0408ab}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[PartSensorState := NOT stInOuts.bI_PartPresenceSensor;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <LineIds Name="fbHP_Axis">
      <LineId Id="3" Count="45" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.ACT_AxisFBs">
      <LineId Id="2" Count="38" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.ACT_AxisWorkSteps">
      <LineId Id="2" Count="279" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.ACT_BackgroundTasks">
      <LineId Id="2" Count="107" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.ACT_WeldingAlghorithm">
      <LineId Id="2" Count="91" />
      <LineId Id="407" Count="0" />
      <LineId Id="94" Count="23" />
      <LineId Id="409" Count="0" />
      <LineId Id="118" Count="288" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.ActualForce.Get">
      <LineId Id="3" Count="3" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.ActualPosition.Get">
      <LineId Id="3" Count="3" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.ActualPresetPosition.Get">
      <LineId Id="3" Count="29" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.ActualVelocity.Get">
      <LineId Id="3" Count="3" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.Enabled.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.Enabled.Set">
      <LineId Id="3" Count="13" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.InSetPos_ConnPos.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.InSetPos_MarkingPos.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.InSetPos_MaxPos.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.InSetPos_MinPos.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.InSetPos_PartLoad.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.InSetPos_SafeHpMove.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.IsCalibrated.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.IsCalibrated.Set">
      <LineId Id="3" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.IsErrorActive.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.IsHomed.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.IsMoving.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.IsReady.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.IsReadyForOperation.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.IsSafeToMoveHP.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.mAddTimeStat">
      <LineId Id="3" Count="2" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.ManualMode.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.ManualMode.Set">
      <LineId Id="3" Count="16" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.mCalibrateAxis">
      <LineId Id="3" Count="23" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.mGoToSafeState">
      <LineId Id="3" Count="11" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.mHomeAxis">
      <LineId Id="3" Count="12" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.mManualMove">
      <LineId Id="3" Count="29" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.mMoveFastToPresetPos">
      <LineId Id="3" Count="30" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.mMoveToAbsPos">
      <LineId Id="3" Count="18" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.mNewEvent">
      <LineId Id="3" Count="21" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.mReadError">
      <LineId Id="3" Count="8" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.mReset">
      <LineId Id="3" Count="13" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.mStartWelding">
      <LineId Id="3" Count="20" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.PartClamp.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.PartClamp.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbHP_Axis.PartSensorState.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>