<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.13">
  <POU Name="fbDetectionTunel" Id="{d674c568-06ca-4fc1-a5b2-62eb1252440e}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK fbDetectionTunel IMPLEMENTS I_StationMachine
VAR_IN_OUT
	stInOuts		: stDetectionTunelInOuts;
	stParams		: stDetectionTunelParams;
END_VAR
VAR
	//
	iWorkStep 		: INT;
	I_PimSystem		: I_PIM;
	//
	fbLoadFiler 		: FB_FilterEx;
	rLoadOffset			: REAL;
	rLastForceMeasure	: REAL := 0;
	bConvoyerOn			: BOOL;
	fbTON_ForceSampling	: TON;
	fbTON_ForceStable	: TON;
	fbTON_TareTimeout	: TON;
	fbTON_StepTimeOut	: TON;
	iDropedBottles		: BYTE;
	fbTON_ConvoyerStop	: TON;
	bServiceReset		: BOOL;
	fbVisionSensor		: fbCognexIS280Control;
	bBottleMassToHigh	: BOOL;
	bBottleMassToLow	: BOOL;
	bBottleWrongCRing	: BOOL;
	bBottleLackOfCRing	: BOOL;
	bLackOfBottle		: BOOL;
	byDetectionStatus	: BYTE;
	fbDetectionWaitTimer: TON;
	fbWaitForStart		: TON;
	fbTON_StartDelay	: TON;
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
//Safety
IF NOT stInOuts.bDorsClosedNO AND iWorkStep < 90 THEN
	mNewEvent(nEventClass := nPIM_EventClasses.Error, nEvent:= nDetectionTunelErrorCodes.safetyError);
END_IF
//Bottle Input filter
fbWaitForStart(IN:=stInOuts.bBottleInput,PT:=INT_TO_TIME(stParams.iStartWaitTime));
//Convoyer Speed Controll
IF bConvoyerOn THEN
	//IF stInOuts.iBeltVolocity < (stParams.iConvoyerMaxSpeed + 32767/stParams.iSpeedingTime) THEN
	//	stInOuts.iBeltVolocity := stInOuts.iBeltVolocity + 32767/stParams.iSpeedingTime;
	//END_IF
	stInOuts.iBeltVolocity:= REAL_TO_INT(INT_TO_REAL(stParams.iConvoyerMaxSpeed)*stParams.rConvoyerSpeed/100);
ELSE
	stInOuts.iBeltVolocity:= 2500;
END_IF
fbVisionSensor(stIo_Data:=stInOuts.stCognex);		

//Load Cell Tare
//--------------------------------------------------------------------------------------------
IF stInOuts.bTarePerform THEN
	IF fbTON_ForceStable.Q THEN
		rLoadOffset := rLoadOffset + ActualWeight;
		stInOuts.bTarePerform := FALSE;
	ELSE
		IF fbTON_TareTimeout.Q THEN
			stInOuts.bTarePerform := FALSE;
			rLoadOffset	:= 0;
			mNewEvent(nEventClass := nPIM_EventClasses.Error, nEvent:= nDetectionTunelErrorCodes.weightCheckWeightTimeOut);
		END_IF
	END_IF
END_IF
fbTON_TareTimeout(IN:= stInOuts.bTarePerform, PT:= T#1S);	

//Load Cell Filter
//--------------------------------------------------------------------------------------------
fbLoadFiler(rIn := stInOuts.stLoadCell.rValue - rLoadOffset, tTimeConstant := UINT_TO_TIME(stParams.iFilterStabilizationTime));
fbTON_ForceSampling(IN:= NOT fbTON_ForceSampling.Q, PT:= T#30MS);
IF fbTON_ForceSampling.Q THEN
	fbTON_ForceStable(IN:= ABS(rLastForceMeasure-ActualWeight)< MAX(0.5,ActualWeight*0.005), PT:= INT_TO_TIME(stParams.iForceStabilTime));
	rLastForceMeasure := ActualWeight;
END_IF


//Actuator controll
stInOuts.bActuatorPerformBack := NOT stInOuts.bActuatorPositioning AND NOT stInOuts.bActuatorDropBottle;
//Auto convoyer turn off
fbTON_ConvoyerStop(IN:= (bConvoyerOn AND NOT stInOuts.bBottleInput), PT:= T#10S);
bConvoyerOn	 R= fbTON_ConvoyerStop.Q;
//Vision params setup
	stParams.bOrangeExpected R= stParams.bGreenExpected;
	stParams.bGreenExpected R= stParams.bOrangeExpected;
//Sequence
//--------------------------------------------------------------------------------------------
CASE iWorkStep OF
	0:	//Initialization
		iWorkStep:= 3;
	3:	//First Taring
		IF fbWaitForStart.Q THEN
			mNewEvent(nEventClass := nPIM_EventClasses.Error, nEvent:= nDetectionTunelErrorCodes.takeOutBottleFormTare);
		ELSE
			//bTarePerform := FALSE;
			iWorkStep:= 5;
		END_IF
	5:	//Checking 
		stInOuts.bActuatorPositioning := stInOuts.bActuatorPushConvoyer := stInOuts.bActuatorDropBottle := FALSE;
		I_PimSystem.mSetNewMachineState(nMachineNewState:=nPim_MachineStates._2_ReadyForNewOperation);
		iWorkStep:= 10;
	10:	//Waiting for next step
		fbTON_StartDelay(IN:= stInOuts.bBottleInput, PT:= T#400MS);
		IF fbTON_StartDelay.Q AND NOT stInOuts.bTarePerform  THEN
			IF I_PimSystem.mSetNewMachineState(nMachineNewState:=nPim_MachineStates._3_NewOperationStarted) THEN
				fbTON_StartDelay(IN:= FALSE);
				stInOuts.bActuatorPositioning := TRUE;
				iWorkStep := 15;
			END_IF
		END_IF
		IF ABS(ActualWeight) >= 7 AND fbTON_ForceStable.Q AND NOT stInOuts.bTarePerform AND stParams.bAutoTaringEnable THEN
			stInOuts.bTarePerform := TRUE;
			rLoadOffset	:= 0;
		END_IF
	15:		// Going back with actuator
		IF stInOuts.bActuatorTestLoad THEN
			I_PimSystem.mSetNewMachineState(nMachineNewState:=nPim_MachineStates._4_OperationInProgress);
			stInOuts.bActuatorPositioning := FALSE;
			iWorkStep:=17;
		END_IF
	17:		//Vision sensor detection
		fbDetectionWaitTimer(IN:=TRUE,PT:=INT_TO_TIME(stParams.iDetectionWaitTime));
		IF stParams.bCognexEnable THEN   
			fbVisionSensor.bTrigger := fbDetectionWaitTimer.Q;
			IF stInOuts.stCognex.bIn0 THEN
				iWorkStep := 18;
				fbVisionSensor.bTrigger := FALSE;
				fbDetectionWaitTimer(IN:=FALSE);
			END_IF
		ELSE
			iWorkStep := 20;
		END_IF
	18:		//Vision sensor wait for end of work
		
		IF NOT stInOuts.stCognex.bIn0 THEN
			IF stParams.bGreenExpected  THEN
				IF stInOuts.stCognex.bIn1 THEN
					iWorkStep := 20;
				ELSIF stInOuts.stCognex.bInOut2 THEN
					bBottleWrongCRing := TRUE;
					iWorkStep := 20;
				ELSIF stInOuts.stCognex.bInOut3 THEN
					bBottleLackOfCRing := TRUE;
					iWorkStep := 20;
				ELSIF NOT stInOuts.stCognex.bIn1 AND NOT stInOuts.stCognex.bInOut2 AND NOT stInOuts.stCognex.bInOut3 THEN
					bLackOfBottle := TRUE;
					iWorkStep := 20;
				END_IF
			ELSIF stParams.bOrangeExpected THEN
				IF stInOuts.stCognex.bIn1 THEN
					bBottleWrongCRing := TRUE;
					iWorkStep := 20;
				ELSIF stInOuts.stCognex.bInOut2 THEN
					iWorkStep := 20;
				ELSIF stInOuts.stCognex.bInOut3 THEN
					bBottleLackOfCRing := TRUE;
					iWorkStep := 20;
				ELSIF NOT stInOuts.stCognex.bIn1 AND NOT stInOuts.stCognex.bInOut2 AND NOT stInOuts.stCognex.bInOut3 THEN
					bLackOfBottle := TRUE;
					iWorkStep := 20;
				END_IF
			END_IF
		END_IF
		IF fbTON_StepTimeOut.Q THEN
			mNewEvent(nEventClass := nPIM_EventClasses.Error, nEvent:= nDetectionTunelErrorCodes.stepTimeOut);
		END_IF
		fbTON_StepTimeOut(IN:=iWorkStep=18,PT:=T#5S);
	20:		//Checking bottle weight
		IF stParams.bWeightCheck THEN
			IF fbTON_ForceStable.Q THEN 
				IF ABS(stParams.rBottleLoad-ActualWeight)<stParams.rBottleLoadTolerance THEN
					iWorkStep := 22;
					iDropedBottles := 0;
				ELSIF  ABS(stParams.rBottleLoad + stParams.rBottleLoadTolerance) < ActualWeight THEN
					bBottleMassToHigh := TRUE;
					iWorkStep := 22;
				ELSIF  ABS(stParams.rBottleLoad - stParams.rBottleLoadTolerance) > ActualWeight THEN
					bBottleMassToLow := TRUE;
					iWorkStep := 22;
				END_IF
			END_IF
			fbTON_StepTimeOut(IN:= (iWorkStep = 20),PT:= T#2S);
		ELSE
			iWorkStep := 22;
		END_IF
	22:	//Pushing out bottle if any detecion was bad
		IF bBottleMassToHigh OR bBottleMassToLow OR bBottleWrongCRing OR bBottleLackOfCRing THEN
			iWorkStep := 70;
		ELSE
			iWorkStep := 25;
		END_IF
	25: //Turning on conveyor and pushing out bottle
		bConvoyerOn := TRUE;
		IF stInOuts.bActuatorHome THEN
			stInOuts.bActuatorPushConvoyer := TRUE;
			iWorkStep:=30;
		END_IF
	30:	//Bottle was push
		IF stInOuts.bActuatorConvoyerPush THEN
			I_PimSystem.mSetNewMachineState(nMachineNewState:=nPim_MachineStates._5_OperationEndedOK);
			stInOuts.bActuatorPushConvoyer := FALSE;
			iWorkStep:=35;
		END_IF
	35:	//Pushing actuator went back
		IF stInOuts.bActuatorConvoyerHome THEN
			I_PimSystem.mSetNewMachineState(nMachineNewState:=nPim_MachineStates._6_ReturningToBaseState);
			iWorkStep:=5;
		END_IF
	70: //Botle pushout
		IF stInOuts.bActuatorConvoyerHome THEN
			stInOuts.bActuatorDropBottle := TRUE;
			iWorkStep := 75;
		ELSE
			stInOuts.bActuatorPushConvoyer := FALSE;
		END_IF
	75: //Botle pushed out botle
		IF stInOuts.bActuatorPush THEN
			stInOuts.bActuatorDropBottle := FALSE;
			iWorkStep := 80;
		END_IF	
	80: //Actuator went back
		IF stInOuts.bActuatorHome THEN
			iWorkStep := 5;
			byDetectionStatus.0 := bBottleWrongCRing;			//+1
			byDetectionStatus.1 := bBottleLackOfCRing;			//+2
			byDetectionStatus.2 := bBottleMassToLow;			//+4
			byDetectionStatus.3 := bBottleMassToHigh;			//+8
			byDetectionStatus.4 := bLackOfBottle;				//+16
			CASE byDetectionStatus OF
				0:	//Nic
					
				1:	//Wrong C Ring
					mNewEvent(nEventClass := nPIM_EventClasses.Error, nEvent:= nDetectionTunelErrorCodes.wrongSealDetected);
				2:	//Lack of C Ring
					mNewEvent(nEventClass := nPIM_EventClasses.Error, nEvent:= nDetectionTunelErrorCodes.lackOfDetectionOfSeal);
				//3:	//Lack of C Ring + Wrong C Ring - nie wsytapi
				
				4:	//Bottle mass to low
					mNewEvent(nEventClass := nPIM_EventClasses.Error, nEvent:= nDetectionTunelErrorCodes.massTooSmall);
				5:	//Bottle mass to low + Wrong C Ring
					mNewEvent(nEventClass := nPIM_EventClasses.Error, nEvent:= nDetectionTunelErrorCodes.bottleMassLowAndWrongCRing);
				6:	//Bottle mass to low + Lack of C Ring
					mNewEvent(nEventClass := nPIM_EventClasses.Error, nEvent:= nDetectionTunelErrorCodes.bottleMassLowAndLackOfCRing);
				//7:	//Bottle mass to low + Wrong C Ring + Lack of C Ring - nie wsytapi
				
				8:	//Bottle mass to high
					mNewEvent(nEventClass := nPIM_EventClasses.Error, nEvent:= nDetectionTunelErrorCodes.massTooHigh);
				9:	//Bottle mass to high + Wrong C Ring
					mNewEvent(nEventClass := nPIM_EventClasses.Error, nEvent:= nDetectionTunelErrorCodes.bottleMassHighAndWrongCRing);
				10:	//Bottle mass to high + Lack of C Ring
					mNewEvent(nEventClass := nPIM_EventClasses.Error, nEvent:= nDetectionTunelErrorCodes.bottleMassHighAndLackOfCRing);
				(*11:	//Bottle mass to high + Wrong C Ring + Lack of C Ring - nie wsytapi
				
				12:	//Bottle mass to high + Bottle mass to low- nie wsytapi
				
				13:	//Bottle mass to high + Bottle mass to low + Lack of C Ring - nie wsytapi
				
				14:	//Bottle mass to high + Bottle mass to low + Wrong C Ring - nie wsytapi
				
				15:	//Bottle mass to high + Bottle mass to low + Wrong C Ring + Lack of C Ring - nie wsytapi*)
				16: //Bottle not detected
					mNewEvent(nEventClass := nPIM_EventClasses.Error, nEvent:= nDetectionTunelErrorCodes.bottleNoBottleDetected);
				20: //Bottle not tetected + Bottle mass too Low
					mNewEvent(nEventClass := nPIM_EventClasses.Error, nEvent:= nDetectionTunelErrorCodes.bottleMassLowAndNoBottleDetected);
				24: //Bottle not tetected + Bottle mass too High
					mNewEvent(nEventClass := nPIM_EventClasses.Error, nEvent:= nDetectionTunelErrorCodes.bottleMassHighAndNoBottleDetected);
				
			END_CASE
			bBottleWrongCRing := bBottleLackOfCRing := bBottleMassToLow := bBottleMassToHigh := FALSE;
		END_IF
	90:	//Error steps
		stInOuts.bActuatorPositioning := stInOuts.bActuatorDropBottle := stInOuts.bActuatorPushConvoyer := FALSE;
		iWorkStep:=91;
	91:	//Waiting for reset
		IF I_PimSystem.mSetNewMachineState(nPIM_MachineStates._9_ResetInProgress) OR bServiceReset THEN
			iWorkStep := 95;
		END_IF
	95:	//Performing reset
		I_PimSystem.mSetNewMachineState(nPIM_MachineStates._0_Standby_NotReady);
		iWorkStep := 5;
END_CASE]]></ST>
    </Implementation>
    <Property Name="ActualWeight" Id="{7d232ba5-d9ea-4fe0-9467-03bc33692ecf}">
      <Declaration><![CDATA[{attribute 'monitoring' := 'call'}
PROPERTY ActualWeight : REAL]]></Declaration>
      <Get Name="Get" Id="{85520b2f-066c-4168-8df0-d2177020389d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[ActualWeight :=fbLoadFiler.rOut;
]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="FB_init" Id="{14c588a1-2051-41ef-8992-63df745ec320}">
      <Declaration><![CDATA[METHOD FB_init : BOOL
VAR_INPUT
	bInitRetains	: BOOL;
	bInCopyCode 	: BOOL;
	I_Pim			: I_PIM;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[I_PimSystem := I_Pim;]]></ST>
      </Implementation>
    </Method>
    <Method Name="mGetParamsData" Id="{15396826-e5fd-4e97-a170-0dc874467447}">
      <Declaration><![CDATA[{warning 'add method implementation '}
(* Metoda TRUE kiedy dane wyjściowe są ok, jeśli nie FALSE (jeśli not bBusy i FALSE to błąd odczytu) *)
METHOD mGetParamsData : BOOL
VAR_INPUT
	(* Jeśli TRUE metoda okresla czy ma dostęp do parametrów, jeśli tak zwraca TRUE, jeśli nie FALSE*)
	bTestParams	: BOOL;
END_VAR
VAR_OUTPUT
	(* Maszyna odświeża dane*)
	bBusy	: BOOL;
	(* Wskaźnik do parametrów pracy maszyny*)
	pMachineParametersStruct	: POINTER TO BYTE;
	(* Rozmiar struktury parametrów pracy maszyny [bajty]*)
	uiMachineParametersSize	: UINT;
	(* Aktualna suma CRC16 obliczona z parametrów*)
	wActualCRC16SumInMachine	: WORD;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF bTestParams THEN
	mGetParamsData := FALSE;
ELSE
	pMachineParametersStruct := 0;
	uiMachineParametersSize := 0;
	bBusy := FALSE;
	mGetParamsData := TRUE;	
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="mNewEvent" Id="{0ab4e3a8-bebe-407b-ac4b-2ad19bbb012b}">
      <Declaration><![CDATA[METHOD INTERNAL mNewEvent : BOOL
VAR_INPUT
	nEventClass:nPIM_EventClasses;
	nEvent: nDetectionTunelErrorCodes;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF nEventClass = nPIM_EventClasses.AlarmAutoConfirm OR nEventClass = nPIM_EventClasses.Message THEN		// Alarm nieblokadowy
	I_PimSystem.mSetNewMachineState(nPIM_MachineStates._0_Initialization);
	iWorkStep := 90;
ELSE
	I_PimSystem.mSetNewMachineState(nPIM_MachineStates._7_ErrorOccurr);

	I_PimSystem.mNewEvent(iEventId := nEvent, nEventType := nEventClass, tMessageTime := T#0S);
	iWorkStep := 90;
END_IF]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="fbDetectionTunel">
      <LineId Id="264" Count="0" />
      <LineId Id="4" Count="15" />
      <LineId Id="384" Count="0" />
      <LineId Id="386" Count="13" />
      <LineId Id="385" Count="0" />
      <LineId Id="20" Count="9" />
      <LineId Id="43" Count="33" />
      <LineId Id="379" Count="1" />
      <LineId Id="382" Count="0" />
      <LineId Id="381" Count="0" />
      <LineId Id="77" Count="26" />
      <LineId Id="330" Count="1" />
      <LineId Id="106" Count="0" />
      <LineId Id="337" Count="1" />
      <LineId Id="336" Count="0" />
      <LineId Id="107" Count="9" />
      <LineId Id="332" Count="2" />
      <LineId Id="117" Count="66" />
      <LineId Id="339" Count="0" />
      <LineId Id="184" Count="32" />
      <LineId Id="344" Count="0" />
      <LineId Id="340" Count="0" />
      <LineId Id="343" Count="0" />
      <LineId Id="342" Count="0" />
      <LineId Id="345" Count="0" />
      <LineId Id="341" Count="0" />
      <LineId Id="217" Count="12" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbDetectionTunel.ActualWeight.Get">
      <LineId Id="3" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbDetectionTunel.FB_init">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbDetectionTunel.mGetParamsData">
      <LineId Id="3" Count="6" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="fbDetectionTunel.mNewEvent">
      <LineId Id="3" Count="7" />
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>