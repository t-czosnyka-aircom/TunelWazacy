<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="FB_TCP_SendString" Id="{d29c3468-bb07-4e75-a5e2-9f820abb2a14}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_TCP_SendString
VAR_INPUT
END_VAR
VAR_OUTPUT
	bError: BOOL;
	bDone:BOOL; //Pulse
END_VAR
VAR
	fbSocketConnect: FB_SocketConnect;
	fbSocketSend: FB_SocketSend;
	fbSocketReceive: FB_SocketReceive;
	fbSocketClose: FB_SocketClose;
	hSocket: T_HSOCKET;
	sData:STRING:='GetVersion;';
	sRecieved:STRING;
	sRespLeft:STRING;
	nRecBytes:UDINT;
	eStep:(WAIT,CONNECT, WAIT_CONNECT, SEND,WAIT_SEND,WAIT_RESPONSE,CLOSE,WAIT_CLOSE,DONE,ERROR);
	fbReceieve_TON: TON;
	fbResponseTimeout_TON: TON;
	fbSequenceTimeout_TON: TON;
	pCurrentSendRequest: POINTER TO ST_TCP_SendRequest;
	stCurrentSendRequest:ST_TCP_SendRequest;
	bNotBusy:BOOL;
	fbMemRingBuffer:FB_MemRingBuffer;

	arBuffer: ARRAY[0 .. BUFFER_SIZE] OF BYTE;
	iBufferInsertIndex:INT:=0;
	iCycleCounter:INT;
END_VAR

VAR CONSTANT
	stEmptySendRequest:ST_TCP_SendRequest;
	BUFFER_PLACES:UINT:=10;
	BUFFER_SIZE:UINT:=BUFFER_PLACES*BUFFER_UNIT_SIZE+20;
	BUFFER_UNIT_SIZE:UINT:=SIZEOF(POINTER TO ST_TCP_SendRequest);
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[bNotBusy:=NOT fbSocketConnect.bBusy AND NOT fbSocketSend.bBusy AND NOT fbSocketReceive.bBusy AND NOT fbSocketClose.bBusy;
CASE eStep OF
	WAIT:
		fbSocketConnect.bExecute:=FALSE;
		fbSocketReceive.bExecute :=FALSE;
		fbSocketSend.bExecute:=FALSE;
		fbSocketClose.bExecute:=FALSE;
		bDone:=FALSE;
		IF bNotBusy AND fbMemRingBuffer.nCount > 0  THEN 
			iCycleCounter :=0;
			fbMemRingBuffer.A_RemoveHead(pRead:=ADR(pCurrentSendRequest),
					cbRead:=SIZEOF(pCurrentSendRequest),
					pBuffer:=ADR(arBuffer),
					cbBuffer:=SIZEOF(arBuffer));
			IF pCurrentSendRequest <> 0 AND_THEN NOT pCurrentSendRequest^.bDone THEN
				eStep:=CONNECT;
				bError:=FALSE;
				pCurrentSendRequest^.bProcesseingInProgress:=TRUE;
				stCurrentSendRequest := pCurrentSendRequest^;
			END_IF
		END_IF

	CONNECT:
		fbSocketConnect.bExecute:=TRUE;
		IF fbSocketConnect.bBusy THEN
			eStep:=WAIT_CONNECT;
		END_IF
		
	WAIT_CONNECT:
		fbSocketConnect.bExecute:=FALSE;
		IF NOT fbSocketConnect.bBusy THEN
			IF NOT fbSocketConnect.bError THEN
				eStep:=SEND;
			ELSE
				eStep:=ERROR;
			END_IF
		END_IF
	
	SEND:	
		IF (pCurrentSendRequest) <> 0 THEN
			sData:=CONCAT(pCurrentSendRequest^.sDataToSend,pCurrentSendRequest^.sSuffix);
			fbSocketSend.bExecute:=TRUE;
			IF fbSocketSend.bBusy THEN
				eStep:= WAIT_SEND;
			END_IF
		ELSE
			eStep:= CLOSE;
		END_IF
		
	WAIT_SEND:
		fbSocketSend.bExecute:=FALSE;
		IF NOT fbSocketSend.bBusy THEN
			IF NOT fbSocketSend.bError THEN
				sRecieved:='';
				IF (pCurrentSendRequest) <> 0 AND_THEN pCurrentSendRequest^.bExpectResponse THEN
					eStep:= WAIT_RESPONSE;
				ELSE
					eStep:= CLOSE;
				END_IF
			ELSE
				eStep:=ERROR;
			END_IF
		END_IF
		
	WAIT_RESPONSE:
		IF sRecieved<>'' AND nRecBytes > 0 AND (pCurrentSendRequest) <> 0 THEN
			pCurrentSendRequest^.sResponse:=LEFT(sRecieved,UDINT_TO_INT(nRecBytes));
			pCurrentSendRequest^.bResponseReceived:=TRUE;
			sRespLeft:=LEFT(pCurrentSendRequest^.sResponse,LEN(pCurrentSendRequest^.sACK_Response));
			IF  sRespLeft=pCurrentSendRequest^.sACK_Response THEN
				pCurrentSendRequest^.bResponseACK:=TRUE;
			END_IF

			eStep:= CLOSE;
			
		ELSIF fbResponseTimeout_TON.Q THEN
			eStep:= CLOSE;
		END_IF
	
	CLOSE:
		fbSocketClose.bExecute:=TRUE;
		IF fbSocketClose.bBusy THEN
			eStep:= WAIT_CLOSE;
		END_IF
		
	WAIT_CLOSE:
		IF NOT fbSocketClose.bBusy THEN
			eStep:= DONE;
		END_IF
		
	ERROR:
		fbSocketClose.bExecute:=TRUE;
		IF (pCurrentSendRequest) <> 0 THEN
			pCurrentSendRequest^.bError:=TRUE;
		END_IF
		eStep := DONE;
		
	DONE:
		bDone:=TRUE;
		IF (pCurrentSendRequest) <> 0 THEN
			pCurrentSendRequest^.bDone:=TRUE;
		END_IF
		stCurrentSendRequest :=stEmptySendRequest;
		pCurrentSendRequest := 0;
		eStep := WAIT;

END_CASE
fbResponseTimeout_TON(IN:=eStep=WAIT_RESPONSE,PT:=T#3S);
fbSequenceTimeout_TON(IN:=eStep<>WAIT AND eStep<>DONE,PT:=T#10S);
fbReceieve_TON(IN:=NOT fbReceieve_TON.Q AND eStep=WAIT_RESPONSE, PT:=T#20MS);


IF fbSequenceTimeout_TON.Q THEN
	eStep:=ERROR;
END_IF

fbSocketConnect(
	sRemoteHost:= stCurrentSendRequest.sIP, 
	nRemotePort:= stCurrentSendRequest.nPort, 
	tTimeout:= T#10S,
	hSocket=>hSocket );
	
fbSocketSend(
	hSocket:=hSocket , 
	cbLen:= LEN(sData), 
	pSrc:= ADR(sData));
	

fbSocketReceive(
	hSocket:=hSocket, 
	cbLen:=255, 
	pDest:=ADR(sRecieved) , 
	bExecute:= eStep=WAIT_RESPONSE AND NOT fbReceieve_TON.Q,
	tTimeout:=T#5S , 
	nRecBytes=> nRecBytes);
	
fbSocketClose(
	hSocket:=hSocket);
	
IF eStep <> WAIT THEN
	iCycleCounter := iCycleCounter + 1;
END_IF
	]]></ST>
    </Implementation>
    <Method Name="mSendRequest" Id="{e2c210ac-86bf-4159-ab4d-938a2ee721d3}">
      <Declaration><![CDATA[METHOD mSendRequest : BOOL
VAR_INPUT
	pSendRequest: POINTER TO ST_TCP_SendRequest;
END_VAR

VAR

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[mSendRequest:=FALSE;
IF pSendRequest <>0  AND  fbMemRingBuffer.nCount < BUFFER_PLACES THEN

	pSendRequest^.bDone:=FALSE;
	pSendRequest^.bProcesseingInProgress:=FALSE;
	pSendRequest^.bError:=FALSE;
	pSendRequest^.bResponseACK:=FALSE;
	pSendRequest^.bResponseReceived:=FALSE;
	pSendRequest^.sResponse:='';
	fbMemRingBuffer.A_AddTail(pWrite:=ADR(pSendRequest),
						cbWrite:=SIZEOF(pSendRequest),
						pBuffer:=ADR(arBuffer),
						cbBuffer:=SIZEOF(arBuffer));
	//pCurrentSendRequest REF= pSendRequest;
	mSendRequest:=fbMemRingBuffer.bOk;
END_IF]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_TCP_SendString">
      <LineId Id="830" Count="141" />
      <LineId Id="174" Count="0" />
    </LineIds>
    <LineIds Name="FB_TCP_SendString.mSendRequest">
      <LineId Id="16" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="21" Count="0" />
      <LineId Id="10" Count="5" />
      <LineId Id="27" Count="2" />
      <LineId Id="26" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="8" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>