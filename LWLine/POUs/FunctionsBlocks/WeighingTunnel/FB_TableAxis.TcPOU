<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.15">
  <POU Name="FB_TableAxis" Id="{63903ec6-2e40-4423-8701-13bc72106aa6}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_TableAxis ////Blok funkcyjny obslugujacy kompleksowao jedna Os 
VAR_INPUT
	stTestParams			: stHP_Axis_TestParams;		
	stSettings				: stHP_Axis_Settings;
	bEmergencyStop 			: BOOL;			// Emergency stop pressed	
	bSTO_Signal 			: BOOL;			// STO signal activated

	lrMarkingPos_mm			: LREAL;
	I_TimeTableRef			: I_TimeTable255;
	sTTRowPreambule			: STRING;
	bELM_ChB				: BOOL;
END_VAR
VAR_OUTPUT
	nActEvent					: nHP_Axis_ErrorList;
	udiActErrorCode				: UDINT;
	bBasePosRefreshWarning		: BOOL;
END_VAR
VAR
	iCurrentPositionNumber		:INT;
	stInOuts					: stHP_Axis_InOuts;
	bEnableMotion				: BOOL;		// When TRUE - try to enable axis, when FALSE disable power - safeState
	McPower 					: MC_Power;
	McReset 					: MC_Reset;
	McStop	 					: MC_Stop;
	McMoveAbs 					: MC_MoveAbsolute;
	McMoveRel 					: MC_MoveRelative;
	McMoveVelocity	 			: MC_MoveVelocity;
	McJog	 					: MC_Jog;
	McReadActualPosition	 	: MC_ReadActualPosition;
	McReadActualVelocity	 	: MC_ReadActualVelocity;
	McHome						: MC_Home;
	McBrakeCtrl					: FB_BrakeControl;
	
	McTorqueMonitor				: FB_TorqueMonitoringEL_Ex2;
	McTorqueCtrl				: MC_TorqueControl;
	stHomimgParams				: ST_HomingOptions;
		



	bDetectCollision_Active: BOOL;
	fbTOF_Accelerating: TOF;
	rCollisionRecordedForce: REAL;
	bLimitSwitchMin: BOOL;
	bLimitSwitchMax: BOOL;
	iWorkStep_Axis: INT;
	iWorkStep_Alghorithm: INT;
	fbFTrig_EmergStop: F_TRIG;
	bDoneReceived: BOOL;
	fbTON_WorkStepTimeout: TON;
	bAlg_Busy, bAlg_Error : BOOL;
	udiAlg_ErrorId	: UDINT;
	iPresenceSensorWorkVerify: INT;
	bHP_InWorkPos: BOOL;

	lrAdjContactPoint_mm: LREAL;
	lrHeatUpPos_mm: LREAL;
	fbTON_WorkStepTime_Alg: TON;
	bAllowToDepartAfterHeatUp: BOOL;

	bHP_InHomePos: BOOL;


	bWeldResultReaded: BOOL;

	lrConnectionContactPoint_mm, lrConnectionContactPointDif_mm: LREAL;
	udiMcError: UDINT;
	fbTON_ManualJogReset: TON;
	udiErrorCodeToRead: UDINT;
	udiMcErrorToRead: UDINT;

	fbRTRIG_ManGoForward: R_TRIG;
	bManModeForceMax: BOOL;
	bTouchingHP: BOOL;
	bOnlySafeState: BOOL;
	lrCalibrationPoint_mm: LREAL;
	bPartBaseCalibration: BOOL;
	bHMI_Plus, bHMI_Minus: BOOL;
	bResetTmr: BOOL;
	

	bSetNewBrakeCtrl: BOOL;
	nAct_BrakeMode, nNew_BrakeMode: nHP_Axis_BrakeMode;
	fbFTRIG_BreakCtrlDone: F_TRIG;
	bTooglePowerState: BOOL;
	bManModeMoveSlower: BOOL;
	fbRTRIG_ManMoveSwitchSlower: R_TRIG;
	lrPartSizeDifference: LREAL;
	iHMI_StepName: INT;
	rConnectingMaxForce: REAL;
	lrTmp: LREAL;
	astErrorHistory: ARRAY [1..10] OF stErrorHistoryRow;
	bWaitForSP: BOOL;
	lrMeltingPrevPosition: LREAL;
	lrMeltingEnergyCalculation: LREAL;
	//Nowe łączenie po sile

	
END_VAR
VAR PERSISTENT
	lrBasePos_mm		: LREAL;
END_VAR
VAR_IN_OUT
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[
// Read drive data
stInOuts.stAxis_Data.ReadStatus();
McReadActualPosition(Axis := stInOuts.stAxis_Data, Enable := TRUE);
McReadActualVelocity(Axis := stInOuts.stAxis_Data, Enable := TRUE);

//Read FB status
ACT_AxisFBs(); 	

ACT_BackgroundTasks();
ACT_AxisWorkSteps();
ACT_AxisFBs(); 	
ACT_WeldingAlghorithm();


IF IsReady AND iWorkStep_Alghorithm = 10	THEN	// Ready for new operation
	iHMI_StepName:= 12;
ELSIF iWorkStep_Alghorithm = 90 OR (iWorkStep_Axis >= 90 AND iWorkStep_Axis < 95) THEN		// Error
	iHMI_StepName:= 17;
ELSIF iWorkStep_Axis = 15 THEN		// Error
	iHMI_StepName:= 11;
ELSIF iWorkStep_Alghorithm >= 15 AND iWorkStep_Alghorithm <= 20 THEN		// Going to PreAdjustment position, waiting for eject HeatedPlate
	iHMI_StepName:= 22;
ELSIF iWorkStep_Alghorithm = 25 THEN		// Melting start delay - simultaneous departure
	iHMI_StepName:= 23;
ELSIF iWorkStep_Alghorithm >= 30 AND iWorkStep_Alghorithm < 33 THEN		// Melting in progress
	iHMI_StepName:= 24;
ELSIF iWorkStep_Alghorithm = 33 THEN		// Heating UP
	iHMI_StepName:= 25;
ELSIF iWorkStep_Alghorithm = 35 THEN		// Wait for permission to departure
	iHMI_StepName:= 26;
ELSIF iWorkStep_Alghorithm >= 40 AND iWorkStep_Alghorithm <= 45 THEN		// Departure from Heated Plate 
	iHMI_StepName:= 27;
ELSIF iWorkStep_Alghorithm = 50 THEN		// Wait for Heated Plate return 
	iHMI_StepName:= 28;
ELSIF iWorkStep_Alghorithm = 55 THEN		// Move to connection position 
	iHMI_StepName:= 29;
ELSIF iWorkStep_Alghorithm >= 56 AND iWorkStep_Alghorithm < 60 THEN		// Connecting 
	iHMI_StepName:= 30;
ELSIF iWorkStep_Alghorithm = 60 THEN		// Cooling down 
	iHMI_StepName:= 31;
	

	
END_IF

]]></ST>
    </Implementation>
    <Folder Name="Methods" Id="{dd1ff324-f717-4be5-94fe-c6790fe36176}" />
    <Folder Name="Properties" Id="{6bcf0577-dc84-4cb2-a2c2-101bd16e9c54}">
      <Folder Name="InPos" Id="{ca235f6c-5338-4750-a585-bb0287fb63f8}" />
    </Folder>
    <Action Name="ACT_AxisFBs" Id="{73b9ad69-da7f-4228-aa52-46745ddb7172}">
      <Implementation>
        <ST><![CDATA[
// Power ON
IF NOT bELM_ChB THEN
	bLimitSwitchMin	:= NOT stInOuts.wI_DriveInfodata.0;
	bLimitSwitchMax	:= NOT stInOuts.wI_DriveInfodata.1;	
ELSE
	bLimitSwitchMin	:= NOT stInOuts.wI_DriveInfodata.8;
	bLimitSwitchMax	:= NOT stInOuts.wI_DriveInfodata.9;	
END_IF
McPower(Axis:=stInOuts.stAxis_Data, Enable:=, Enable_Positive:=NOT bLimitSwitchMax, Enable_Negative:= (NOT bLimitSwitchMin OR McHome.Active));

// Error reset
McReset(Axis:=stInOuts.stAxis_Data);

// Homing
McHome(Axis := stInOuts.stAxis_Data, Position := 0, HomingMode := MC_HomingMode.MC_DefaultHoming, bCalibrationCam := bLimitSwitchMin, Options := stHomimgParams);

// Stop FBs
McStop(Axis := stInOuts.stAxis_Data, Deceleration := 15000, Jerk := 100000);
McBrakeCtrl(Axis := stInOuts.stAxis_Data);
fbFTRIG_BreakCtrlDone(CLK:= McBrakeCtrl.Busy);
IF fbFTRIG_BreakCtrlDone.Q THEN
	IF McBrakeCtrl.Mode = eBrakeMode_Automatic THEN	nAct_BrakeMode := nHP_Axis_BrakeMode.BrakeMode_Automatic;
	ELSIF McBrakeCtrl.Mode = eBrakeMode_Lock THEN nAct_BrakeMode := nHP_Axis_BrakeMode.BrakeMode_Lock;
	ELSIF McBrakeCtrl.Mode = eBrakeMode_Unlock THEN nAct_BrakeMode := nHP_Axis_BrakeMode.BrakeMode_Unlock;
	END_IF
END_IF
McBrakeCtrl.Execute := FALSE;
// Motion FBs

McJog(Axis := stInOuts.stAxis_Data, Mode := MC_JOGMODE_CONTINOUS, Acceleration := stSettings.rAcceleration, Deceleration := stSettings.rDeceleration, Jerk := 100000);
McMoveAbs(Axis := stInOuts.stAxis_Data, Acceleration := stSettings.rAcceleration, Deceleration := stSettings.rDeceleration, Jerk := 100000);
McMoveRel(Axis := stInOuts.stAxis_Data, Acceleration := stSettings.rAcceleration, Deceleration := stSettings.rDeceleration, Jerk := 100000);
McMoveVelocity(Axis := stInOuts.stAxis_Data, Acceleration := stSettings.rAcceleration, Deceleration := stSettings.rDeceleration, Jerk := 100000);

// Torque limitation
McTorqueMonitor( bCalculate:= bSTO_Signal,
	rTorqueLimit:= ,
	Axis:= stInOuts.stAxis_Data);
McTorqueCtrl(Axis := stInOuts.stAxis_Data, Relative := FALSE, ContinuousUpdate := TRUE, TorqueRamp := 100);]]></ST>
      </Implementation>
    </Action>
    <Action Name="ACT_AxisWorkSteps" Id="{3d028214-21ec-47e4-9d64-ba13043f4390}">
      <Implementation>
        <ST><![CDATA[
fbFTrig_EmergStop(CLK:= bEmergencyStop);
IF fbFTrig_EmergStop.Q THEN
	iWorkStep_Axis := 90;
END_IF
IF NOT bEmergencyStop AND iWorkStep_Axis < 90 THEN
	mNewEvent(nEvent := nHP_Axis_ErrorList.STO_SignalActive, ErrorCode:= 0);
	bOnlySafeState := FALSE;
ELSIF NOT bEnableMotion AND Enabled AND bEmergencyStop AND iWorkStep_Axis > 5 AND iWorkStep_Axis < 92 THEN		// Regular disable (when opewn workcover)
	iWorkStep_Axis := 92;
END_IF

CASE iWorkStep_Axis OF
	0:	// Inicjalizacja
		McPower.Enable := McReset.Execute := McHome.Execute := McStop.Execute := FALSE;
		McJog.JogForward := McJog.JogBackwards := McMoveAbs.Execute := McMoveRel.Execute := McMoveVelocity.Execute := FALSE; 
		iWorkStep_Axis := 1;
		
	1:	// Sprawdzenie parametrów pracy
		stSettings.rSlowSpeed_mm_s := LIMIT(0.5, stSettings.rSlowSpeed_mm_s, 10);
		stSettings.rFastSpeed_mm_s := LIMIT(50, stSettings.rFastSpeed_mm_s, 320);
		stSettings.rDeceleration := LIMIT(100, stSettings.rDeceleration, 5000);
		stSettings.rAcceleration := LIMIT(100, stSettings.rAcceleration, 5000);
		stSettings.lrMax_Pos := LIMIT(100, stSettings.lrMax_Pos, 300); 
		iWorkStep_Axis := 5;
		
	5: 	// Sprawdzenie gotowości do załączenia
		IF IsErrorActive THEN
			mNewEvent( nEvent := nHP_Axis_ErrorList.MotionFB_Error,ErrorCode:= stInOuts.stAxis_Data.Status.ErrorID);
		END_IF
		IF McPower.Enable THEN
			IF McPower.Status THEN
				iWorkStep_Axis := 10;
			ELSIF McPower.Error THEN
				mNewEvent( nEvent := nHP_Axis_ErrorList.MotionFB_Error,ErrorCode:= McPower.ErrorID);
			END_IF
		ELSE 
			IF bEnableMotion THEN
				bOnlySafeState := FALSE;
				McPower.Enable :=  TRUE;
			END_IF
		END_IF
		
	10:	// Axis ready for new Cmds
		IF IsErrorActive THEN
			mNewEvent( nEvent := nHP_Axis_ErrorList.MotionFB_Error,ErrorCode:= stInOuts.stAxis_Data.Status.ErrorID);
		END_IF
		fbTON_WorkStepTimeout(IN:= FALSE);
		bDoneReceived := FALSE;
		
	15:	// Manual mode
		IF bResetTmr THEN
			bResetTmr := FALSE;
			fbTON_ManualJogReset(IN:= FALSE);
		END_IF
		fbTON_ManualJogReset(IN:= McJog.Active, PT:= T#250MS);
		IF fbTON_ManualJogReset.Q THEN
			McJog.JogForward := McJog.JogBackwards := FALSE;
		END_IF
		// Breake control
		IF bSetNewBrakeCtrl THEN
			McBrakeCtrl.Mode := nNew_BrakeMode;
			McBrakeCtrl.Execute := TRUE;	
			bSetNewBrakeCtrl := FALSE; 
		// Enable/disable axis
		ELSIF bTooglePowerState THEN
			McPower.Enable := NOT McPower.Enable;
 			bTooglePowerState := FALSE;
		ELSE
			McPower.Enable S= McJog.JogForward OR McJog.JogBackwards;
		END_IF	
	
	20:	// Homing
		IF McHome.Execute THEN
			IF McHome.Done THEN
				fbTON_WorkStepTimeout(IN:= FALSE);
				iWorkStep_Axis := 21;		// Acurate
			ELSIF McHome.Error THEN
				mNewEvent( nEvent := nHP_Axis_ErrorList.MotionFB_Error,ErrorCode:= McHome.ErrorID);
		//	ELSIF NOT McHome.Busy THEN
		//		mNewEvent( nEvent := nHP_Axis_ErrorList.MotionFB_NotBusy,ErrorCode:= 0);
			END_IF
		ELSE 
			stHomimgParams.SearchDirection := MC_Direction.MC_Negative_Direction;
			stHomimgParams.SyncDirection := MC_Direction.MC_Positive_Direction;
			stHomimgParams.SearchVelocity := 30.0;
			stHomimgParams.SyncVelocity := 1;
			stHomimgParams.ReferenceMode := E_EncoderReferenceMode.ENCODERREFERENCEMODE_DEFAULt;
			McHome.Execute := TRUE;
		END_IF
			
	21:	// Home done
		fbTON_WorkStepTimeout(IN:= TRUE,PT:=T#100MS);
		IF bDoneReceived OR fbTON_WorkStepTimeout.Q THEN
			McHome.Execute := FALSE;
			iWorkStep_Axis := 10;	
		END_IF
		
	30:	// Move to absolute position
		IF McMoveAbs.Execute THEN
			IF McMoveAbs.Done THEN
				iWorkStep_Axis := 31;		// Done
			ELSIF McMoveAbs.Error THEN
				mNewEvent(nEvent := nHP_Axis_ErrorList.MotionFB_Error, ErrorCode:= McMoveAbs.ErrorID);
		//	ELSIF NOT McMoveAbs.Busy THEN
		//		mNewEvent(nEvent := nHP_Axis_ErrorList.MotionFB_NotBusy,ErrorCode:= 0);
			END_IF
		ELSE 
			McMoveAbs.Execute := TRUE;
		END_IF
	
	31:	// Move ABS done
		fbTON_WorkStepTimeout(IN:= TRUE,PT:=T#100MS);
		IF bDoneReceived OR fbTON_WorkStepTimeout.Q THEN
			McMoveAbs.Execute := FALSE;
			iWorkStep_Axis := 10;	
		END_IF
		
	40:	// Calibrate axis - base axis
		bBasePosRefreshWarning := bPartBaseCalibration := FALSE;
		rPartSizeDifference_Mean := 0.0;
		fbTON_WorkStepTimeout(IN:= TRUE,PT:=T#1S);
		IF McMoveVelocity.Execute THEN
			IF NOT fbTOF_Accelerating.Q AND fbTON_ForceStable.Q THEN
				fbTON_WorkStepTimeout(IN:= FALSE);
				bTaring := TRUE;
				iWorkStep_Axis := 41;
			END_IF
		ELSE 
			IF IsHomed THEN
				McMoveVelocity.Execute := TRUE;
				McMoveVelocity.Direction := MC_Direction.MC_Positive_Direction;
				McMoveVelocity.Velocity := stSettings.rSlowSpeed_mm_s;
			END_IF
		END_IF
		IF fbTON_WorkStepTimeout.Q THEN
			mNewEvent(nEvent := nHP_Axis_ErrorList.MotionFB_Error, ErrorCode:= INT_TO_UDINT(iWorkStep_Axis));
		END_IF
	
	41:	// Wait for taring
		fbTON_WorkStepTimeout(IN:= TRUE,PT:=T#2S);
		IF NOT bTaring THEN
			lrCalibrationPoint_mm := 0.0;
			McMoveVelocity.Execute := FALSE;
			fbTON_WorkStepTimeout(IN:= FALSE);
			iWorkStep_Axis := 42;
		ELSIF fbTON_WorkStepTimeout.Q THEN
			mNewEvent(nEvent := nHP_Axis_ErrorList.ForceTaringError, ErrorCode:= INT_TO_UDINT(iWorkStep_Axis));			
		END_IF
		
	42:	// Wait for contact - force rising
		fbTON_WorkStepTimeout(IN:= TRUE,PT:=T#4M);
		IF ActualForce >= stTestParams.rAdjContactDetectForce_N THEN
			lrCalibrationPoint_mm := ActualPosition;
			IF bPartBaseCalibration THEN
				lrBasePos_mm := lrCalibrationPoint_mm;
			END_IF
			McMoveRel.Execute := TRUE;
			McMoveRel.Distance := -10.0;
			McMoveRel.Velocity := 5*stSettings.rSlowSpeed_mm_s;
			iWorkStep_Axis := 43;
		END_IF
		IF fbTON_WorkStepTimeout.Q OR InSetPos_MaxPos THEN
			mNewEvent(nEvent := nHP_Axis_ErrorList.BasePosSearchTimeout, ErrorCode:= INT_TO_UDINT(iWorkStep_Axis));			
		END_IF

	43:	// Reverse axis to safe position 
		IF McMoveRel.Execute THEN
			IF  McMoveRel.Done THEN
				fbTON_WorkStepTimeout(IN:= FALSE);
				McMoveRel.Execute := FALSE;
				iWorkStep_Axis := 44;
			ELSIF McMoveRel.Error THEN
				mNewEvent(nEvent := nHP_Axis_ErrorList.MotionFB_Error, ErrorCode:= McMoveRel.ErrorID);
			END_IF
		ELSE 
			McMoveRel.Execute := TRUE;
			McMoveRel.Distance := -10.0;
			McMoveRel.Velocity := 5*stSettings.rSlowSpeed_mm_s;
		END_IF 
		
	44:	// Wait for result readed
		fbTON_WorkStepTimeout(IN:= TRUE,PT:=T#100MS);
		IF bDoneReceived OR fbTON_WorkStepTimeout.Q THEN
			bPartBaseCalibration := FALSE;
			iWorkStep_Axis := 10;	
		END_IF
		
	90:	// Go to Safe position
		McMoveVelocity.Execute := McMoveAbs.Execute := McMoveRel.Execute := McStop.Execute := FALSE;
		iWorkStep_Axis := 92;		// Domyślnie tylko wyłącz napęd
		IF Enabled AND NOT stInOuts.stAxis_Data.Status.Error AND (IsHomed AND ActualPosition > 20) THEN// AND (bTouchingHP OR (ActualForce > 20 AND NOT bTaring) ) THEN	// Drive homed, ready and position is greather than load position - reverse fixture
			PartClamp := TRUE;
			iWorkStep_Axis := 91;		
		END_IF
		
	91:	// Reverse fixture which is potentially touches heated plate
		IF McMoveRel.Execute THEN
			IF  McMoveRel.Done OR NOT bSTO_Signal THEN
				McMoveRel.Execute := FALSE;
				iWorkStep_Axis := 92;
			ELSIF McMoveRel.Error THEN
				mNewEvent(nEvent := nHP_Axis_ErrorList.MotionFB_Error, ErrorCode:= McMoveRel.ErrorID);
				// NOthing to do
				McMoveRel.Execute := FALSE;
				iWorkStep_Axis := 92;
			END_IF
		ELSIF stInOuts.stAxis_Data.Status.Operational AND NOT McMoveRel.Execute THEN 
			McMoveRel.Execute := TRUE;
			McMoveRel.Distance := -30.0;
			McMoveRel.Velocity := stSettings.rFastSpeed_mm_s;
		END_IF 
	
	92:	// Stop drive and disable power
		IF McStop.Execute THEN
			IF McStop.Done OR NOT Enabled OR McStop.Error THEN	// Disable axis - cant do anything
				McStop.Execute := FALSE;
				McPower.Enable := FALSE;
				IF bOnlySafeState THEN
					bOnlySafeState := FALSE;				
					iWorkStep_Axis := 5;	
				ELSE
					iWorkStep_Axis := 94;	
				END_IF

			END_IF
		ELSE 
			IF Enabled THEN
				McStop.Execute := TRUE;
			ELSE
				IF bOnlySafeState THEN
					bOnlySafeState := FALSE;				
					iWorkStep_Axis := 5;	
				ELSE
					iWorkStep_Axis := 94;	
				END_IF				
			END_IF
		END_IF 
		
	94:	// Axis wait for reset	- NOP
		bConnectingActive := bMeltingActive := McReset.Execute := FALSE;
		fbTON_WorkStepTimeout(IN:= FALSE);
	
	95: // Axis reset
		bOnlySafeState := FALSE;
		PartClamp := FALSE;
		iWorkStep_Alghorithm := 0;
		fbTON_WorkStepTimeout(IN:= TRUE,PT:=T#2S);
		IF McReset.Execute THEN
			IF McReset.Done THEN	// Reset axis
				McReset.Execute := FALSE;
				fbTON_WorkStepTimeout(IN:= FALSE);
				iWorkStep_Axis := 96;
			ELSIF McReset.Error THEN		//NOT McReset.Busy OR 
				McReset.Execute := FALSE;
				iWorkStep_Axis := 97;
			END_IF
		ELSE 
			McHome.Execute := McStop.Execute := McJog.JogForward := McJog.JogBackwards := FALSE;
			McMoveAbs.Execute := McMoveRel.Execute := McMoveVelocity.Execute := FALSE; 
			IF stInOuts.stAxis_Data.Status.Error THEN
				McReset.Execute := TRUE;
			ELSE
				fbTON_WorkStepTimeout(IN:= FALSE);
				iWorkStep_Axis := 96;
			END_IF
		END_IF
		
	96:	// Reset succesfull
		nActEvent := nHP_Axis_ErrorList.NoError;
		fbTON_WorkStepTimeout(IN:= TRUE, PT:= T#40MS);
		IF fbTON_WorkStepTimeout.Q THEN
			fbTON_WorkStepTimeout(IN:= FALSE);
			iWorkStep_Axis := 5;
		END_IF
		
	97:	// Reset error
		nActEvent := nHP_Axis_ErrorList.MotionFB_Error;
		iWorkStep_Axis := 90;	
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Action Name="ACT_BackgroundTasks" Id="{493f8999-0915-4fab-b3bc-539904dfa200}">
      <Implementation>
        <ST><![CDATA[// General signal preparation

// Colision detection	----------------------------------------------------------------------------------
fbTOF_Accelerating(IN:= stInOuts.stAxis_Data.Status.Accelerating ,PT:= T#40MS);
IF bDetectCollision_Active AND_THEN stSettings.bColisionDettection_EN AND NOT ManualMode AND
		(ActualForce >= stSettings.rCollisionDetectForce_N AND NOT fbTOF_Accelerating.Q OR ABS(ActualForce) >= 2*stSettings.rCollisionDetectForce_N) THEN
	bDetectCollision_Active := FALSE;
	rCollisionRecordedForce := ActualForce;
	mNewEvent(nEvent := nHP_Axis_ErrorList.ColisionDetected, ErrorCode:= REAL_TO_UDINT(ActualForce));
	McStop.Execute := TRUE;
	GVL_Aircom.fbFormatString(sFormat := 'Kolizja wykryta, pozycja %.3f[mm], sila kolizji %.2f[N]',
			 arg1:= F_LREAL(McReadActualPosition.Position),
			 arg2:= F_REAL(rCollisionRecordedForce));
	mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
END_IF

]]></ST>
      </Implementation>
    </Action>
    <Action Name="ACT_WeldingAlghorithm" Id="{fde34ca3-b836-436c-a3bd-dd6a07315347}">
      <Implementation>
        <ST><![CDATA[		

CASE iWorkStep_Alghorithm OF
	0:		// Check if
		fbTON_WorkStepTime_Alg(IN:= FALSE);
		bCoolingActive := bMeltingActive := bConnectingActive := bDetectCollision_Active := FALSE;
		iWorkStep_Alghorithm := 10;
		
	10: 	// Waiting for new operation
		IF NOT PartSensorState THEN
			iPresenceSensorWorkVerify:= 0;	
		END_IF
		
	15:		// Reset test data and test preconditions (if part is present)
		lrAdjContactPoint_mm := lrMeltingEnergyCalculation := lrHeatUpPos_mm := 0.0;
		lrConnectionContactPoint_mm := 0.0;
		rMeltingTime := rCollisionRecordedForce := rConnectingMaxForce := 0.0;
		bWaitForSP := FALSE;
		IF stSettings.bPartInFixtureDetection_EN THEN 
			IF iPresenceSensorWorkVerify > 3 THEN
				mNewEvent(nEvent:= nHP_Axis_ErrorList.PartDetectSensorFailure, ErrorCode := 0);
			ELSIF NOT PartSensorState THEN	// Jeśli włączona detekcja części a nie ma jej w uchwycie - błąd
				mNewEvent(nEvent:= nHP_Axis_ErrorList.PartNotDetectedInFixture, ErrorCode := 0);
			ELSE
				mAddTimeStat(sText := 'Czesc obecna w uchwycie');
				iPresenceSensorWorkVerify:= iPresenceSensorWorkVerify + 1;
				bTaring := TRUE;
				iWorkStep_Alghorithm := 16;
			END_IF
		ELSE
			bTaring := TRUE;
			iWorkStep_Alghorithm := 16;
		END_IF
		fbTON_WorkStepTime_Alg(IN:= FALSE);
			
	16:		// Wait for taring
		fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#1S);
		PartClamp S= NOT stTestParams.bPartLockAfterHpContact;
		IF NOT bTaring THEN
			fbTON_WorkStepTime_Alg(IN:= FALSE);
			iWorkStep_Alghorithm := 17;
		ELSIF fbTON_WorkStepTime_Alg.Q THEN
			mNewEvent(nEvent := nHP_Axis_ErrorList.ForceTaringError, ErrorCode:= REAL_TO_UDINT(ActualForce));
		END_IF

	17:		// Part level adjusting and melting
		fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#3S);
		bDetectCollision_Active := TRUE;
		bPartsConnected := FALSE;
		// Go on safe position and wait for HP open signal
		IF mMoveFastToPresetPos(nSetPos := nHP_Axis_PresetPositions.SafeHpMove_Pos,bError => bAlg_Error)
					AND_THEN NOT bAlg_Error THEN
			mAddTimeStat(sText := 'Oczekiwanie w pozycji bezpiecznej na otwarcie plyty grzejnej');
			iWorkStep_Alghorithm := 20;
		ELSIF fbTON_WorkStepTime_Alg.Q OR bAlg_Error THEN
			mNewEvent(nEvent:= nHP_Axis_ErrorList.MotionWorkStepTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
		END_IF
		IF iWorkStep_Alghorithm <> 15 THEN fbTON_WorkStepTime_Alg(IN:= FALSE); END_IF
		
	20:		// Wait for HP open signal and Go to pre base point
		IF bHP_InWorkPos THEN
			fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#3S);
			IF mMoveFastToPresetPos(nSetPos := nHP_Axis_PresetPositions.PreBase_Pos,bError => bAlg_Error) 
					AND_THEN NOT bAlg_Error THEN
				mAddTimeStat(sText := 'Oczekiwanie na start dopasowania');
				iWorkStep_Alghorithm := 25;
			ELSIF fbTON_WorkStepTime_Alg.Q OR bAlg_Error THEN
				mNewEvent(nEvent:= nHP_Axis_ErrorList.MotionWorkStepTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
			END_IF
		END_IF
		IF iWorkStep_Alghorithm <> 20 THEN fbTON_WorkStepTime_Alg(IN:= FALSE); END_IF
		
	25:		// Wait in prebase position for permision to start adjustment (time synchronization)
		bDetectCollision_Active := FALSE;
		IF rMeltingDelay_ms <100 OR fbTON_WorkStepTime_Alg.Q THEN
			mAddTimeStat(sText := 'Start dopasowania');
			fbTON_WorkStepTime_Alg(IN:= FALSE);
			iWorkStep_Alghorithm := 30;
		ELSE
			fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= REAL_TO_TIME(rMeltingDelay_ms));
		END_IF
		
	30:		// Adjusting by melting part- looking for contact point
		fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#5S);
		IF McMoveVelocity.Execute THEN
			IF ActualForce >= stTestParams.rAdjContactDetectForce_N THEN
				lrAdjContactPoint_mm := ActualPosition;
				lrPartSizeDifference := lrAdjContactPoint_mm - lrBasePos_mm; 
				fMeanFilter(rInputValue:= LREAL_TO_REAL(lrPartSizeDifference), rDelta := 10, rMeanValue := rPartSizeDifference_Mean);
			
				IF stTestParams.bCheckPartToleranceAfterContact AND_THEN ABS(lrPartSizeDifference) > stTestParams.lrPartToleranceFromBasePos_mm THEN
					IF (lrPartSizeDifference) > 0 THEN
						
						mNewEvent(nEvent:= nHP_Axis_ErrorList.PartDimmOutsideToleranceToLow, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
					ELSE
						mNewEvent(nEvent:= nHP_Axis_ErrorList.PartDimmOutsideToleranceToHigh, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
					END_IF
				ELSE
					GVL_Aircom.fbFormatString(sFormat := 'Kontakt czesci osiagniety, pozycja %.3f[mm], roznica wzgledem bazy %.3f[mm]',
							 arg1:= F_LREAL(lrAdjContactPoint_mm),
							 arg2:= F_LREAL(lrPartSizeDifference));
					mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
					bBasePosRefreshWarning S= ABS(rPartSizeDifference_Mean) > 0.75*LREAL_TO_REAL(stTestParams.lrPartToleranceFromBasePos_mm);
					fbTON_WorkStepTime_Alg.PT:= REAL_TO_TIME(stTestParams.rMeltingTimeout_s*1000);
					bWaitForSP := TRUE;
					lrMeltingPrevPosition := ActualPosition;
					iWorkStep_Alghorithm := 31;
				END_IF
			ELSIF (ActualPosition - lrBasePos_mm) > 1.5*(stTestParams.lrPartToleranceFromBasePos_mm) AND stTestParams.lrPartToleranceFromBasePos_mm > 0.02 THEN
				mNewEvent(nEvent:= nHP_Axis_ErrorList.AdjustmentContactForceNotDetected, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
			END_IF
		ELSE
			McMoveVelocity.Direction := MC_Direction.MC_Positive_Direction;
			McMoveVelocity.Velocity := stSettings.rSlowSpeed_mm_s;
			McMoveVelocity.Execute := TRUE;
		END_IF
		IF fbTON_WorkStepTime_Alg.Q THEN
			McMoveVelocity.Execute := FALSE;
			mNewEvent(nEvent:= nHP_Axis_ErrorList.AdjustmentContactDetectionTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
		END_IF
		
	31:		// Level adjustment by melting part	
		fbTON_WorkStepTime_Alg(IN:= TRUE);
		PartClamp S= ActualForce > 0.75*(stTestParams.rMeltingForce_N);
		bMeltingActive:= TRUE;
		fbMc_ForcePID.SET_POINT := stTestParams.rMeltingForce_N; 
		fbMc_ForcePID.ACTUAL := ActualForce;
		bPID_ForceRegulation := stTestParams.bMeltingForceRegulation;
		lrMeltingEnergyCalculation := lrMeltingEnergyCalculation + 0.01*ActualForce*(ActualPosition - lrMeltingPrevPosition);	// Obliczanie energii
		lrMeltingPrevPosition := ActualPosition;
		IF fbTON_WorkStepTime_Alg.Q THEN
			mNewEvent(nEvent:= nHP_Axis_ErrorList.AdjustmentDistnaceNotReachTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
		ELSE
			CASE stTestParams.nMeltingMode OF
				nHP_Axis_AdjustmentModes.FitByDRM:
					IF ActualPosition >= (lrAdjContactPoint_mm + stTestParams.lrMeltingDistance_mm) THEN
						rMeltingTime:= TIME_TO_REAL(fbTON_WorkStepTime_Alg.ET)/1000.0;
						iWorkStep_Alghorithm := 32; 
						GVL_Aircom.fbFormatString(sFormat := 'Osiagnieto droge dopasowania w czasie %.1f[s] (pozycja %.3f[mm], energia %.3f[J])',
							arg1:= F_REAL(rMeltingTime),
							arg2:= F_LREAL(McReadActualPosition.Position),
							arg3:= F_LREAL(lrMeltingEnergyCalculation));
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
					END_IF

				nHP_Axis_AdjustmentModes.FitByABS:
					IF ActualPosition >= (stTestParams.lrMeltingDistance_mm) THEN
						rMeltingTime:= TIME_TO_REAL(fbTON_WorkStepTime_Alg.ET)/1000.0;
						iWorkStep_Alghorithm := 32; 
						lrTmp := ActualPosition - lrAdjContactPoint_mm;
						GVL_Aircom.fbFormatString(sFormat := 'Osiagnieto odleglosc ABS w czasie %.1f[s] (droga dopasowania %.3f[mm], energia %.3f[J])',
							arg1:= F_REAL(rMeltingTime),
							arg2:= F_LREAL(lrTmp),
							arg3:= F_LREAL(lrMeltingEnergyCalculation));
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
					END_IF			
			END_CASE
			IF iWorkStep_Alghorithm <> 31 THEN
				bMeltingActive:= FALSE;
				McMoveVelocity.Execute := FALSE;
				McStop.Execute := TRUE;
				fbTON_WorkStepTime_Alg(IN:= FALSE); 
			END_IF
		END_IF
			
	32:		// Halt after achieved target melting point
		PartClamp := TRUE;
		IF McStop.Done THEN
			bAllowToDepartAfterHeatUp := FALSE;
			fbTON_WorkStepTime_Alg(IN:= FALSE, PT:= REAL_TO_TIME(stTestParams.rHeatingUpTime_s*1000));
			iWorkStep_Alghorithm := 33;
		ELSIF McStop.Error THEN
			bMeltingActive:= FALSE;
			mNewEvent(nEvent:= nHP_Axis_ErrorList.MotionFB_Error, ErrorCode := McStop.ErrorID);
		END_IF
		IF iWorkStep_Alghorithm <> 32 THEN 
			McStop.Execute := FALSE; 
			fbTON_WorkStepTime_Alg(IN:= FALSE); 
		END_IF
	
	33:		// Heat up part  - no movement
		fbTON_WorkStepTime_Alg(IN:= TRUE);
		IF fbTON_WorkStepTime_Alg.Q THEN
			lrHeatUpPos_mm := ActualPosition;
			GVL_Aircom.fbFormatString(sFormat := 'Nagrzewanie zakonczone, pozycja HeatUp %.3f[mm])',
						 arg1:= F_LREAL(McReadActualPosition.Position)); 
				mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
			iWorkStep_Alghorithm := 35;
		END_IF
		IF iWorkStep_Alghorithm <> 33 THEN fbTON_WorkStepTime_Alg(IN:= FALSE); END_IF
		
	35:		// Part heated up
		IF bAllowToDepartAfterHeatUp THEN
			rAdhesionMaxForce := 0;
			IF stTestParams.rAdhesionForceLimit_N > 0.1 THEN
				iWorkStep_Alghorithm := 40;
			ELSE 
				iWorkStep_Alghorithm := 45;
			END_IF
			
		END_IF
		
	40:		// Departure from Heated Plate
		fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#4S);
		IF fbTON_WorkStepTime_Alg.Q THEN
			McMoveVelocity.Execute := FALSE;
			McStop.Execute := TRUE;
			mNewEvent(nEvent:= nHP_Axis_ErrorList.DepartureFromHeatedPlateTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
		ELSIF McMoveVelocity.Execute THEN
			rAdhesionMaxForce := MIN(rAdhesionMaxForce, ActualForce);
			IF ActualPosition < (lrHeatUpPos_mm-1.0) AND ABS(ActualForce) < stTestParams.rAdhesionForceLimit_N THEN			
				McMoveVelocity.Execute := FALSE;
				iWorkStep_Alghorithm := 45;
			ELSIF ABS(ActualForce) > (1.05*stTestParams.rAdhesionForceLimit_N) AND McMoveVelocity.Velocity > 0.0 THEN
				McMoveVelocity(Axis := stInOuts.stAxis_Data, Execute := FALSE);
				McMoveVelocity.Execute := TRUE;
				McMoveVelocity.Velocity := 0;
			ELSIF ABS(ActualForce) < (0.95*stTestParams.rAdhesionForceLimit_N) AND McMoveVelocity.Velocity <= 0.1 THEN
				McMoveVelocity(Axis := stInOuts.stAxis_Data, Execute := FALSE);
				McMoveVelocity.Execute := TRUE;
				McMoveVelocity.Velocity := 3*stSettings.rSlowSpeed_mm_s;
			END_IF
		ELSE
			McMoveVelocity.Direction := MC_Direction.MC_Negative_Direction;
			McMoveVelocity.Velocity := 3*stSettings.rSlowSpeed_mm_s;
			McMoveVelocity.Execute := TRUE;
		END_IF
		IF iWorkStep_Alghorithm <> 40 THEN fbTON_WorkStepTime_Alg(IN:= FALSE); END_IF
		
	45:		// After adjustment and depart from heated plate done go to safe pos to allow to hide heated plate
		fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#3S);
		bDetectCollision_Active S= ActualPosition < (lrHeatUpPos_mm-2.0);
		rAdhesionMaxForce := MIN(rAdhesionMaxForce, ActualForce);
		IF mMoveFastToPresetPos(nSetPos := nHP_Axis_PresetPositions.SafeHpMove_Pos,bError => bAlg_Error) 
			 	AND_THEN NOT bAlg_Error THEN
			GVL_Aircom.fbFormatString(sFormat := 'Odjazd od plyty zakonczony, max adhezja %.1f[N])',
					 arg1:= F_REAL(rAdhesionMaxForce)); 
			mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
			iWorkStep_Alghorithm := 50;
		ELSIF fbTON_WorkStepTime_Alg.Q OR bAlg_Error THEN
			mNewEvent(nEvent:= nHP_Axis_ErrorList.MotionWorkStepTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
		END_IF
		IF iWorkStep_Alghorithm <> 45 THEN fbTON_WorkStepTime_Alg(IN:= FALSE); END_IF
		
	50:		// Wait for hide Heat plate to home position and go to desired connecting position
		bDetectCollision_Active := TRUE;
		bConnectingActive:= FALSE;
		IF bHP_InHomePos THEN	
			fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#3S);
			IF stTestParams.nConnectingMode = nHP_Axis_ConnectionModes.None THEN		// Jedź na pozycję łączenia czyli tam gdzie zakończyło się nagrzewanie i czekaj na zakończenie operacji
				IF mMoveFastToPresetPos(nSetPos := nHP_Axis_PresetPositions.Connection_Pos, bError => bAlg_Error)
						AND_THEN NOT bAlg_Error THEN
					GVL_Aircom.fbFormatString(sFormat := 'Os w punkcie laczenia (%.3f[mm])- koniec cyklu osi',
							 arg1:= F_LREAL(McReadActualPosition.Position)); 
					mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
					iWorkStep_Alghorithm := 70;
				END_IF
			ELSE	// Jedć na pozycję przed pkt. zgrzewania czyli pozycja zakończenia nagrzewania + grubość płyty - Xmm (np. 1mm)
				IF mMoveFastToPresetPos(nSetPos := nHP_Axis_PresetPositions.PreConnection_Pos, bError => bAlg_Error) 
						AND_THEN NOT bAlg_Error THEN
					GVL_Aircom.fbFormatString(sFormat := 'Os w punkcie PreLaczenia %.3f[mm]',
							 arg1:= F_LREAL(McReadActualPosition.Position)); 
					mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
					bStartConnecting := FALSE;
					iWorkStep_Alghorithm := 55;
				END_IF
			END_IF
			IF fbTON_WorkStepTime_Alg.Q OR bAlg_Error THEN
				mNewEvent(nEvent:= nHP_Axis_ErrorList.MotionWorkStepTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
			END_IF
		END_IF
		IF iWorkStep_Alghorithm <> 50 THEN 
			bDetectCollision_Active := FALSE;
			fbTON_WorkStepTime_Alg(IN:= FALSE); 
		END_IF
		
	55:		// Connecting- looking for contact point
		IF bStartConnecting THEN
			fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= T#5S);
			IF McMoveVelocity.Execute THEN
				IF ActualForce >= stTestParams.rConContactDetecForce_N THEN
					lrConnectionContactPoint_mm := ActualPosition;
					lrConnectionContactPointDif_mm := lrConnectionContactPoint_mm - lrHeatUpPos_mm;
					GVL_Aircom.fbFormatString(sFormat := 'Laczenie- wykryto kontakt czesci. Roznica wzgl obliczonego %.3f[mm]',
							arg1:= F_LREAL(lrConnectionContactPointDif_mm)); 
					mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
					fbTON_WorkStepTime_Alg(IN:= FALSE);
					iWorkStep_Alghorithm := 56;
				ELSIF ActualPosition > (lrHeatUpPos_mm + lrHeatPlateHeight_mm+5.0) THEN
					mNewEvent(nEvent:= nHP_Axis_ErrorList.ConnectionTouchPointDetectTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
				END_IF
			ELSE
				McMoveVelocity.Direction := MC_Direction.MC_Positive_Direction;
				McMoveVelocity.Velocity := stSettings.rSlowSpeed_mm_s;
				McMoveVelocity.Execute := TRUE;
			END_IF		
			IF fbTON_WorkStepTime_Alg.Q THEN
				mNewEvent(nEvent:= nHP_Axis_ErrorList.ConnectionTouchPointDetectTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
			END_IF
		END_IF
		IF iWorkStep_Alghorithm <> 55 THEN fbTON_WorkStepTime_Alg(IN:= FALSE); END_IF	
			
	56:		// Connecting
		fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= REAL_TO_TIME(stTestParams.rConnectingTimeout_s*1000+stTestParams.rStabilForceConnectingTime*1000*BOOL_TO_REAL(nHP_Axis_ConnectionModes.FitByForceNew=stTestParams.nConnectingMode)));
		bConnectingActive:= TRUE;
		fbMc_ForcePID.ACTUAL := ActualForce;	// rExternalForce_N;
		fbMc_ForcePID.SET_POINT := stTestParams.rConnectingForce_N; 
		//bPID_ForceRegulation := FALSE; //
		bPID_ForceRegulation := (nHP_Axis_ConnectionModes.FitByForceNew = stTestParams.nConnectingMode); //
		bConnectionMinForceReached S= ActualForce > stTestParams.rConnectingMinForce_N;
		IF rConnectingMaxForce < ActualForce THEN
 			rConnectingMaxForce := ActualForce;
		END_IF
		CASE stTestParams.nConnectingMode OF
			nHP_Axis_ConnectionModes.FitByDRM:
				IF ActualPosition >= (lrConnectionContactPoint_mm + stTestParams.lrConnectingDistance_mm) THEN
					IF stTestParams.rConnectingMinForce_N > 0 AND NOT bConnectionMinForceReached THEN	// Wykrywanie siły włącozne oraz siła nie osiągnięta
						GVL_Aircom.fbFormatString(sFormat := 'Laczenie DRM- nie osiagnieto min sily laczenia %.1f[N] (max. sila laczenia %.1f[N])',
								arg1:= F_REAL(stTestParams.rConnectingMinForce_N),
								arg2:= F_REAL(rConnectingMaxForce));
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
						mNewEvent(nEvent:= nHP_Axis_ErrorList.ConnectionNoMinForceReached, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
					ELSE
						GVL_Aircom.fbFormatString(sFormat := 'Laczenie DRM- osiagnieto droge laczenia %.3f[mm], poz. %.3f[mm], max sila %.1f[N]',
								arg1:= F_LREAL(stTestParams.lrConnectingDistance_mm),
								arg2:= F_LREAL(McReadActualPosition.Position),
								arg3:= F_REAL(rConnectingMaxForce));
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
						iWorkStep_Alghorithm := 57;
					END_IF
				END_IF
				
			nHP_Axis_ConnectionModes.FitByABS:
//				IF ActualPosition >= (lrBasePos_mm + lrHeatPlateHeight_mm + stTestParams.lrConnectingDistance_mm) THEN
				IF ActualPosition >= (lrHeatUpPos_mm + lrHeatPlateHeight_mm + stTestParams.lrConnectingDistance_mm) THEN
					IF stTestParams.rConnectingMinForce_N > 0 AND NOT bConnectionMinForceReached THEN	// Wykrywanie siły włącozne oraz siła nie osiągnięta
						GVL_Aircom.fbFormatString(sFormat := 'Laczenie ABS- nie osiagnieto min sily laczenia %.1f[N] (max. sila laczenia %.1f[N])',
								arg1:= F_REAL(stTestParams.rConnectingMinForce_N),
								arg2:= F_REAL(rConnectingMaxForce));
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
						mNewEvent(nEvent:= nHP_Axis_ErrorList.ConnectionNoMinForceReached, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
					ELSE
						lrTmp:= ActualPosition - lrConnectionContactPoint_mm;
						GVL_Aircom.fbFormatString(sFormat := 'Laczenie ABS- osiagnieto droge laczenia, poz. %.3f[mm], max sila %.1f[N], droga %.2f[mm]',
								arg1:= F_LREAL(McReadActualPosition.Position),
								arg2:= F_REAL(rConnectingMaxForce),
								arg3:= F_LREAL(lrTmp),);
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
						iWorkStep_Alghorithm := 57;
					END_IF 
				END_IF		
			
			nHP_Axis_ConnectionModes.FitByForce:
				IF ActualForce > stTestParams.rConnectingForce_N THEN
					IF ActualPosition < (lrConnectionContactPoint_mm + stTestParams.lrConnectingDistance_mm) THEN
						lrTmp:= ActualPosition - lrConnectionContactPoint_mm;
						GVL_Aircom.fbFormatString(sFormat := 'Laczenie na sile- nie osiagnieto min drogi laczenia (aktualna/zadana %.3f/%.3f[mm]',
								arg1:= F_LREAL(lrTmp),
								arg2:= F_LREAL(stTestParams.lrConnectingDistance_mm));
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
						mNewEvent(nEvent:= nHP_Axis_ErrorList.ConnectionNoMinDistanceReached, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
					ELSE	
						lrTmp:= ActualPosition - lrConnectionContactPoint_mm;
						GVL_Aircom.fbFormatString(sFormat := 'Laczenie na sile- pozycja %.3f[mm], droga %.3f[mm]',
								arg1:= F_LREAL(McReadActualPosition.Position),
								arg2:= F_LREAL(lrTmp));
						mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
						iWorkStep_Alghorithm := 57;
					END_IF 
				END_IF		
			nHP_Axis_ConnectionModes.FitByForceNew:
				bForceConnectingForceArchived S= ActualForce >= (stTestParams.rConnectingForce_N - 1) ;
				bForceConnectingForceArchived R= ABS(1-(ActualForce/stTestParams.rConnectingForce_N)) > 0.4; //Wykonaj reset jeżeli różnica w sile jest większa niż 40 %
				
				fbForceConnectingTimer(IN:=bForceConnectingForceArchived,PT:=REAL_TO_TIME(stTestParams.rStabilForceConnectingTime*1000));
				IF fbForceConnectingTimer.Q THEN
					lrTmp:= ActualPosition - lrConnectionContactPoint_mm;
					GVL_Aircom.fbFormatString(sFormat := 'Laczenie na sile osiągnięto czas - pozycja %.3f[mm], droga %.3f[mm]',
							arg1:= F_LREAL(McReadActualPosition.Position),
							arg2:= F_LREAL(lrTmp));
					mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
					fbForceConnectingTimer(IN:=FALSE);
					bForceConnectingForceArchived R= TRUE;
					bPID_ForceRegulation := FALSE;
					iWorkStep_Alghorithm := 57;
				ELSIF ActualPosition > (lrConnectionContactPoint_mm + stTestParams.lrConnectingDistance_mm) THEN
					lrTmp:= ActualPosition - lrConnectionContactPoint_mm;
					GVL_Aircom.fbFormatString(sFormat := 'Laczenie na sile osiągnięto pozycję - pozycja %.3f[mm], droga %.3f[mm]',
							arg1:= F_LREAL(McReadActualPosition.Position),
							arg2:= F_LREAL(lrTmp));
					mAddTimeStat(sText :=GVL_Aircom.fbFormatString.sOut);
					fbForceConnectingTimer(IN:=FALSE);
					bForceConnectingForceArchived R= TRUE;
					bPID_ForceRegulation := FALSE;
					iWorkStep_Alghorithm := 57;
				END_IF	
		END_CASE
		IF fbTON_WorkStepTime_Alg.Q THEN
			fbForceConnectingTimer(IN:=FALSE);
			bForceConnectingForceArchived R= TRUE;
			bPID_ForceRegulation := FALSE;
			mNewEvent(nEvent:= nHP_Axis_ErrorList.ConnectionTimeout, ErrorCode := INT_TO_UDINT(iWorkStep_Alghorithm));
		END_IF
		IF iWorkStep_Alghorithm <> 56 THEN 
			bConnectingActive:= FALSE;
			McMoveVelocity.Execute := FALSE;
			McStop.Execute := TRUE;
			fbTON_WorkStepTime_Alg(IN:= FALSE); 
		END_IF
			
	57:		// Connetion ended - cool down
		IF McStop.Done THEN
			McStop.Execute := FALSE; 
			fbTON_WorkStepTime_Alg(IN:= FALSE);
			iWorkStep_Alghorithm := 60;
		ELSIF McStop.Error THEN
			McStop.Execute := FALSE; 
			mNewEvent(nEvent:= nHP_Axis_ErrorList.MotionFB_Error, ErrorCode := McStop.ErrorID);
		END_IF
		
	60:		// Cooling down
		bPID_ForceRegulation := stTestParams.bAllowCoolingForceAquire;
		bCoolingActive:= stTestParams.bAllowCoolingForceAquire;
		fbMc_ForcePID.ACTUAL := ActualForce;
		fbMc_ForcePID.SET_POINT := stTestParams.rFirstCoolingForceSetUp - (stTestParams.rFirstCoolingForceSetUp - stTestParams.rSecondCoolingforceSetUp)*(TIME_TO_REAL(fbTON_WorkStepTime_Alg.ET)/(stTestParams.rCoolingDownTime_s*1000));
		fbTON_WorkStepTime_Alg(IN:= TRUE, PT:= REAL_TO_TIME(stTestParams.rCoolingDownTime_s*1000));
		IF fbTON_WorkStepTime_Alg.Q THEN		// Parts connected
			fbTON_WorkStepTime_Alg(IN:= FALSE);
			bPID_ForceRegulation := FALSE;
			bCoolingActive:= FALSE;
			McMoveVelocity.Execute := FALSE;
			McStop.Execute := TRUE;
			iWorkStep_Alghorithm := 65;
		END_IF
		
	65:	//Stop	
		IF McStop.Done THEN
			McStop.Execute := FALSE; 
			fbTON_WorkStepTime_Alg(IN:= FALSE);
			iWorkStep_Alghorithm := 70;
		ELSIF McStop.Error THEN
			McStop.Execute := FALSE; 
			mNewEvent(nEvent:= nHP_Axis_ErrorList.MotionFB_Error, ErrorCode := McStop.ErrorID);
		END_IF
		
	70:		// Connection ended
		IF bWeldResultReaded THEN
			iWorkStep_Alghorithm := 0;	
		END_IF
		
	90:		// Error occurr
		fbTON_WorkStepTime_Alg(IN:= FALSE);
		
END_CASE
]]></ST>
      </Implementation>
    </Action>
    <Property Name="ActualForce" Id="{33bf48fa-da52-4841-88f3-798f36a2f2e5}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY ActualForce : REAL]]></Declaration>
      <Get Name="Get" Id="{0c4e947d-6281-4bfd-9af1-5ced60a28b86}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF NOT stInOuts.stLoadCell_Data.wStatus.1 AND NOT stInOuts.stLoadCell_Data.wStatus.3 AND NOT stInOuts.stLoadCell_Data.wStatus.6 THEN
	ActualForce := fbForceFilter.rOut;
ELSE
	ActualForce := -1;
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="ActualPosition" Id="{3d448bb9-2423-42f4-9bb4-23ca6a0609f3}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY ActualPosition : LREAL]]></Declaration>
      <Get Name="Get" Id="{208832f3-b171-4059-a3df-a0a520f96632}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF McReadActualPosition.Valid AND IsHomed THEN		
	ActualPosition := McReadActualPosition.Position;
ELSE
	ActualPosition := -1;
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="ActualPresetPosition" Id="{a4769f74-e373-4b8f-8f67-9c06cce3ab7e}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY ActualPresetPosition : nHP_Axis_PresetPositions]]></Declaration>
      <Get Name="Get" Id="{f378a6bb-4234-4014-aaa8-de6fcfa221e0}">
        <Declaration><![CDATA[VAR
	rHist:REAL;
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[rHist := 0.5;
IF ActualPosition < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.MIN_Pos;

ELSIF ActualPosition > (stSettings.lrMax_Pos - rHist) THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.MAX_Pos;

ELSIF ABS(ActualPosition-stSettings.lrService_Pos_mm) < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.Service_Pos;

ELSIF ABS(ActualPosition-stTestParams.lrSafeHpMovementPos_mm) < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.SafeHpMove_Pos;

ELSIF ABS(ActualPosition-stTestParams.lrPartLoadPosition_mm) < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.PartLoad_Pos;

ELSIF ABS(ActualPosition-(lrBasePos_mm - stTestParams.lrPreBaseOffset_mm)) < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.PreBase_Pos;

ELSIF ABS(ActualPosition-(lrHeatUpPos_mm - stTestParams.lrPreConnectingOffset_mm)) < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.PreConnection_Pos;

ELSIF ABS(ActualPosition-lrHeatUpPos_mm + lrHeatPlateHeight_mm) < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.Connection_Pos;

ELSIF ABS(ActualPosition-lrMarkingPos_mm) < rHist THEN
	ActualPresetPosition := nHP_Axis_PresetPositions.Marking_Pos;
	
ELSE
	ActualPresetPosition := nHP_Axis_PresetPositions.UnDefined;
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="ActualVelocity" Id="{2a25e87f-74a3-4921-af3e-3e78505ad872}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY ActualVelocity : LREAL]]></Declaration>
      <Get Name="Get" Id="{2cbb78ce-cc0f-4958-9d2d-8ee6c4d0de3a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF McReadActualVelocity.Valid THEN
	ActualVelocity := McReadActualVelocity.ActualVelocity;
ELSE
	ActualVelocity := -1;
END_IF]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="Enabled" Id="{112713b8-e2a9-4601-8539-c8e1ea2c4e84}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY Enabled : BOOL]]></Declaration>
      <Get Name="Get" Id="{ad69c5aa-e14d-490a-b055-8e3b2369ef3c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[Enabled:= McPower.Status;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{1bc33316-2a9d-421c-b443-c7c7cbf78376}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF Enabled AND bSTO_Signal THEN
	bEnableMotion := TRUE;	
	McPower.Enable := TRUE;
	ACT_AxisFBs();
ELSE
	IF IsMoving THEN
		mNewEvent( nEvent := nHP_Axis_ErrorList.ProgramError ,ErrorCode:= INT_TO_UDINT(iWorkStep_Axis));	
		bEnableMotion := FALSE;
	ELSE
		bEnableMotion := FALSE;	
		McPower.Enable := FALSE;
		ACT_AxisFBs();
		iWorkStep_Axis := 5;
	END_IF
END_IF]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="InSetPos_ConnPos" Id="{0ee7d99d-7a3c-44e1-aa6f-1b1f1dc9f1c0}" FolderPath="Properties\InPos\">
      <Declaration><![CDATA[PROPERTY InSetPos_ConnPos : BOOL]]></Declaration>
      <Get Name="Get" Id="{a2b37ea8-ba3c-43dc-800c-905d0a5a7451}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[InSetPos_ConnPos := ABS(ActualPosition-(lrHeatUpPos_mm + lrHeatPlateHeight_mm)) < 0.5 AND lrHeatUpPos_mm > stTestParams.lrSafeHpMovementPos_mm AND lrHeatUpPos_mm > 10.0;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="InSetPos_MarkingPos" Id="{d8a51d98-ab37-41d3-9a57-161aa1a6e62d}" FolderPath="Properties\InPos\">
      <Declaration><![CDATA[PROPERTY InSetPos_MarkingPos : BOOL]]></Declaration>
      <Get Name="Get" Id="{e389cec7-cf45-4544-9165-cfb42dbf9d57}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[InSetPos_MarkingPos := ABS(ActualPosition-lrMarkingPos_mm) < 0.5;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="InSetPos_MaxPos" Id="{2587a029-7408-4b6c-854b-34dd84683f8b}" FolderPath="Properties\InPos\">
      <Declaration><![CDATA[PROPERTY InSetPos_MaxPos : BOOL]]></Declaration>
      <Get Name="Get" Id="{8418072f-530d-4eca-a497-90fe54d4526f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[InSetPos_MaxPos := ABS(ActualPosition- stSettings.lrMax_Pos) < 0.5;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="InSetPos_MinPos" Id="{165d2b43-f089-464e-af22-470ccd04bd17}" FolderPath="Properties\InPos\">
      <Declaration><![CDATA[PROPERTY InSetPos_MinPos : BOOL]]></Declaration>
      <Get Name="Get" Id="{afe66109-171e-4a5a-9801-f4560bf4d221}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[InSetPos_MinPos := ABS(ActualPosition) < 0.5;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="InSetPos_PartLoad" Id="{d90b1200-b0df-424e-aaa3-3180d3b11e1c}" FolderPath="Properties\InPos\">
      <Declaration><![CDATA[PROPERTY InSetPos_PartLoad : BOOL]]></Declaration>
      <Get Name="Get" Id="{c6a00700-fb8a-462d-bf9d-88b764c806e6}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[InSetPos_PartLoad := ABS(ActualPosition-stTestParams.lrPartLoadPosition_mm) < 0.5;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="InSetPos_SafeHpMove" Id="{ed2cb4ee-3327-405f-a7af-8df6e98d3cb7}" FolderPath="Properties\InPos\">
      <Declaration><![CDATA[PROPERTY InSetPos_SafeHpMove : BOOL]]></Declaration>
      <Get Name="Get" Id="{a7f441b5-8e3e-4b8a-98c0-1b67189c92ed}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[InSetPos_SafeHpMove := ABS(ActualPosition-stTestParams.lrSafeHpMovementPos_mm) < 0.5;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsCalibrated" Id="{a32f9e99-e0ac-4b0b-ac6e-87fe0ee744ee}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY IsCalibrated : BOOL]]></Declaration>
      <Get Name="Get" Id="{fe0c435c-37d1-4341-a0e2-14048acf762a}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsCalibrated := lrBasePos_mm > 1.0;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{e88d47cf-939b-4872-9e4d-0348d8e8905f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF NOT IsCalibrated THEN
	lrBasePos_mm := 0.0;
END_IF]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="IsErrorActive" Id="{73f1566e-9306-40c3-9a6c-62f12d078dc5}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY IsErrorActive : BOOL]]></Declaration>
      <Get Name="Get" Id="{381f3793-1d43-4806-beed-66bee2ee4d48}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsErrorActive := stInOuts.stAxis_Data.Status.Error OR iWorkStep_Axis >= 90 OR iWorkStep_Alghorithm >= 90;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsHomed" Id="{70d0f684-12a2-46cb-8fcd-b3de806764e8}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY IsHomed : BOOL]]></Declaration>
      <Get Name="Get" Id="{326f58a9-ef02-4404-9579-4d9df7ffaf54}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsHomed := stInOuts.stAxis_Data.Status.Homed;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsMoving" Id="{1007a535-ba04-4605-8a67-7333b3990ed5}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY IsMoving : BOOL]]></Declaration>
      <Get Name="Get" Id="{721be6ec-95f5-4b9a-ba31-ebd67d566060}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsMoving := stInOuts.stAxis_Data.Status.Moving;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsReady" Id="{773961de-2b2e-4d9f-a5a2-7c08da07405c}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY IsReady : BOOL]]></Declaration>
      <Get Name="Get" Id="{837e6687-8bce-47fe-b7df-f380aee77823}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsReady := stInOuts.stAxis_Data.Status.Operational AND NOT stInOuts.stAxis_Data.Status.Error AND McPower.Status AND iWorkStep_Axis = 10;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsReadyForOperation" Id="{97d0f058-3d5e-4718-aa63-45b65574087c}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY IsReadyForOperation : BOOL]]></Declaration>
      <Get Name="Get" Id="{37fee178-b7e4-49b9-9228-76112e77d6f6}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsReadyForOperation := IsReady AND iWorkStep_Alghorithm = 10;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="IsSafeToMoveHP" Id="{1b8fe0ce-1bfa-4616-b0ac-0bdb4ad2dcd8}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY IsSafeToMoveHP : BOOL]]></Declaration>
      <Get Name="Get" Id="{a828164b-e90f-4aba-9994-9777520cb4f4}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IsSafeToMoveHP := IsHomed AND ActualPosition <= (stTestParams.lrSafeHpMovementPos_mm+0.2);]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Method Name="mAddTimeStat" Id="{b23d8941-acad-4596-bc74-1b3dee4bfaab}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mAddTimeStat : BOOL
VAR_INPUT
	sText 		: STRING(255);
END_VAR
VAR
	sTextTmp	: STRING(255);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF I_TimeTableRef <> 0 THEN
	CONCAT2(pSrcString1 := ADR(sTTRowPreambule), pSrcString2 := ADR(sText), pDstString := ADR(sTextTmp), nDstSize := SIZEOF(sTextTmp));
	I_TimeTableRef.mPushText(sText := sTextTmp);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="ManualMode" Id="{5a9cb9e7-a68d-4990-9052-7a87921e2b77}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY ManualMode : BOOL]]></Declaration>
      <Get Name="Get" Id="{680b3cdd-8649-476c-8cc9-08f7b32652be}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[ManualMode := iWorkStep_Axis = 15;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{05f13b57-22bb-4253-a91c-a88d2b11126c}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[IF ManualMode AND NOT IsErrorActive THEN		
	bEnableMotion := TRUE;	
	McPower.Enable := TRUE;
	ACT_AxisFBs();
	IF Enabled THEN
		iWorkStep_Axis := 15;
	END_IF	
ELSIF NOT ManualMode THEN
	IF iWorkStep_Axis = 15 THEN
		McJog(Axis:= stInOuts.stAxis_Data, JogForward := FALSE, JogBackwards := FALSE);
		bEnableMotion := TRUE;	
		McPower.Enable := FALSE;
		McBrakeCtrl.Execute := TRUE;
		McBrakeCtrl.Mode := E_BrakeMode.eBrakeMode_Automatic;
		ACT_AxisFBs();
		iWorkStep_Axis := 5;		
	END_IF
END_IF]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Method Name="mCalibrateAxis" Id="{facfa9d8-e192-4c35-a8f3-a8aca5b43ea1}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mCalibrateAxis : BOOL
VAR_INPUT
	bPartCalib	: BOOL;
END_VAR
VAR_OUTPUT
	bBusy		: BOOL;
	bError		: BOOL;
	udiErrorId	: UDINT;
	lrContactPos: LREAL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsReady THEN
	lrCalibrationPoint_mm := 0.0;
	iWorkStep_Axis := 40;
	bBusy := TRUE;	
ELSIF iWorkStep_Axis >= 40 AND iWorkStep_Axis < 44 THEN
	bBusy := TRUE;
	bPartBaseCalibration := bPartCalib;
	lrContactPos := lrCalibrationPoint_mm;
ELSIF iWorkStep_Axis = 44 THEN
	bBusy := FALSE;
	lrContactPos := lrCalibrationPoint_mm;
	mCalibrateAxis := bDoneReceived := TRUE;
	bError := lrCalibrationPoint_mm < 1.0;
ELSE
	mCalibrateAxis := TRUE;
	bError := TRUE;
	IF nActEvent <> 0 THEN
		udiErrorId := nActEvent;
	ELSIF udiActErrorCode <> 0 THEN
		udiErrorId := udiActErrorCode;
	ELSE	
		udiErrorId := INT_TO_UINT(iWorkStep_Axis);		
	END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mGoToSafeState" Id="{6d4c9b1c-2fc0-470e-b4c7-7d38235086f1}" FolderPath="Methods\">
      <Declaration><![CDATA[// Method for external force axis to move to safe position in desired time
METHOD mGoToSafeState : BOOL]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF iWorkStep_Axis < 90 THEN
	IF NOT bOnlySafeState THEN
		McHome.Execute := McStop.Execute := FALSE;
		McJog.JogForward := McJog.JogBackwards := McMoveAbs.Execute := McMoveRel.Execute := McMoveVelocity.Execute := FALSE; 
		ACT_AxisFBs();
		iWorkStep_Axis := 90;
		iWorkStep_Alghorithm := 0;
		bOnlySafeState := TRUE;
	ELSIF bOnlySafeState THEN
		mGoToSafeState := NOT Enabled;
	END_IF	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mHomeAxis" Id="{797690e8-5052-4099-aee7-c7c895868ab1}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mHomeAxis : BOOL
VAR_INPUT
END_VAR
VAR_OUTPUT
	bBusy		: BOOL;
	bError		: BOOL;
	udiErrorId	: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsReady THEN
	iWorkStep_Axis := 20;
	bBusy := TRUE;
ELSIF iWorkStep_Axis >= 20 AND iWorkStep_Axis <= 24 THEN
	bBusy := McHome.Busy;
	mHomeAxis := bDoneReceived := McHome.Done;
	bError := McHome.Error;
	udiErrorId := McHome.ErrorID;
ELSE
	mHomeAxis := TRUE;
	bError := TRUE;
	udiErrorId := INT_TO_UINT(iWorkStep_Axis);	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mManualMove" Id="{c537e98c-363e-4e20-b844-cdaff9ba756b}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mManualMove : BOOL
VAR_INPUT
	bGoUp		: BOOL;
	bGoDown		: BOOL;
	bSlow		: BOOL;
	bFast		: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF bGoUp OR bGoDown THEN
	bHMI_Plus := bHMI_Minus := FALSE;
	fbTON_ManualJogReset(IN:= FALSE);	
END_IF
fbRTRIG_ManGoForward(CLK:= bGoUp OR bHMI_Plus);
bManModeForceMax R= fbRTRIG_ManGoForward.Q; 
bManModeForceMax S= (ActualForce > stSettings.rManualModeMaxForceAtSlow AND stSettings.rManualModeMaxForceAtSlow > 0.0);
bManModeMoveSlower S= stSettings.rManualModeMaxForceAtSlow > 0 AND bSlow AND ActualForce >= 5;
bManModeMoveSlower R= ActualForce < 4 OR stSettings.rManualModeMaxForceAtSlow <= 0.1 OR NOT bSlow;
fbRTRIG_ManMoveSwitchSlower(CLK:= bManModeMoveSlower);
IF fbRTRIG_ManMoveSwitchSlower.Q THEN
		McJog(Axis := stInOuts.stAxis_Data, JogBackwards := FALSE, JogForward := FALSE);	
END_IF

IF bSlow THEN
	IF bManModeMoveSlower  THEN
		McJog.Velocity := LIMIT(0.1, stSettings.rSlowSpeed_mm_s/4, 4);
	ELSE
		McJog.Velocity := LIMIT(0.5, stSettings.rSlowSpeed_mm_s, 4);		
	END_IF
	McJog.JogForward := (bHMI_Plus OR bGoUp) AND NOT bGoDown AND NOT bManModeForceMax;
	McJog.JogBackwards := (bHMI_Minus OR bGoDown) AND NOT bGoUp;
ELSIF bFast THEN
	McJog.Velocity := 20;
	McJog.JogForward := bGoUp AND NOT bGoDown;
	McJog.JogBackwards := bGoDown AND NOT bGoUp;
ELSE	
	McJog.Velocity := LIMIT(0.1, stSettings.rSlowSpeed_mm_s/2, 4);
	McJog.JogForward := bHMI_Plus AND NOT bHMI_Minus AND NOT bManModeForceMax;
	McJog.JogBackwards := bHMI_Minus AND NOT bHMI_Plus;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="mMoveFastToPresetPos" Id="{fb95d826-f3c4-4554-9f79-41278ed5dd16}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mMoveFastToPresetPos : BOOL
VAR_INPUT
	nSetPos		: nHP_Axis_PresetPositions;
END_VAR
VAR_OUTPUT
	bBusy		: BOOL;
	bError		: BOOL;
	udiErrorId	: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsReady THEN
	CASE nSetPos OF
		nHP_Axis_PresetPositions.MIN_Pos:	McMoveAbs.Position := 0.0;
		nHP_Axis_PresetPositions.MAX_Pos:	McMoveAbs.Position := stSettings.lrMax_Pos;
		nHP_Axis_PresetPositions.Service_Pos:	McMoveAbs.Position := stSettings.lrService_Pos_mm;
		nHP_Axis_PresetPositions.SafeHpMove_Pos:	McMoveAbs.Position := stTestParams.lrSafeHpMovementPos_mm;
		nHP_Axis_PresetPositions.PartLoad_Pos:	McMoveAbs.Position := stTestParams.lrPartLoadPosition_mm;
		nHP_Axis_PresetPositions.PreBase_Pos:	McMoveAbs.Position := lrBasePos_mm - stTestParams.lrPreBaseOffset_mm;
		nHP_Axis_PresetPositions.PreConnection_Pos:		McMoveAbs.Position := lrHeatUpPos_mm - stTestParams.lrPreConnectingOffset_mm;
		nHP_Axis_PresetPositions.Connection_Pos:	McMoveAbs.Position := lrHeatUpPos_mm + lrHeatPlateHeight_mm;
		nHP_Axis_PresetPositions.Marking_Pos:	McMoveAbs.Position := lrMarkingPos_mm;
	END_CASE
	 
	IF McMoveAbs.Position >= 1.0 OR nSetPos = nHP_Axis_PresetPositions.MIN_Pos  THEN
		McMoveAbs.Velocity := LIMIT(10, stSettings.rFastSpeed_mm_s, 320);
		iWorkStep_Axis := 30;
		bBusy := TRUE;
	ELSE
		mMoveFastToPresetPos := bError := TRUE;
	END_IF
	
ELSIF iWorkStep_Axis >= 30 AND iWorkStep_Axis <= 34 THEN
	bBusy := McMoveAbs.Busy;
	mMoveFastToPresetPos := bDoneReceived := McMoveAbs.Done;
	bError := McMoveAbs.Error;
	udiErrorId := McMoveAbs.ErrorID;
ELSE
	mMoveFastToPresetPos := TRUE;
	bError := TRUE;
	udiErrorId := INT_TO_UINT(iWorkStep_Axis);	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mMoveToAbsPos" Id="{fa218288-8707-4a64-b0a2-9153c09807ba}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mMoveToAbsPos : BOOL
VAR_INPUT
	lrSetPos		: LREAL;
	bFastSpeed		: BOOL;
END_VAR
VAR_OUTPUT
	bBusy		: BOOL;
	bError		: BOOL;
	udiErrorId	: UDINT;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF IsReady THEN
	McMoveAbs.Position := LIMIT(0.0, lrSetPos, stSettings.lrMax_Pos);
	IF bFastSpeed THEN
		McMoveAbs.Velocity := LIMIT(10, stSettings.rFastSpeed_mm_s, 320);
	ELSE
		McMoveAbs.Velocity := LIMIT(0.5, stSettings.rSlowSpeed_mm_s, 20);
	END_IF
	iWorkStep_Axis := 30;
	bBusy := TRUE;	
ELSIF iWorkStep_Axis >= 30 AND iWorkStep_Axis <= 34 THEN
	bBusy := McMoveAbs.Busy;
	mMoveToAbsPos := bDoneReceived := McMoveAbs.Done;
	bError := McMoveAbs.Error;
	udiErrorId := McMoveAbs.ErrorID;
ELSE
	mMoveToAbsPos := TRUE;
	bError := TRUE;
	udiErrorId := INT_TO_UINT(iWorkStep_Axis);	
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="mNewEvent" Id="{d2971dcb-9dc3-4108-ad93-3ad39ed84d08}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD INTERNAL mNewEvent : BOOL
VAR_INPUT
	nEvent: nHP_Axis_ErrorList;
	ErrorCode: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
MEMMOVE(srcAddr:= ADR(astErrorHistory[1]), destAddr := ADR(astErrorHistory[2]), n:= 9* SIZEOF(astErrorHistory[1]));
astErrorHistory[1].tTimeStamp := TIME();
astErrorHistory[1].sDescription := TO_STRING(nEvent);
astErrorHistory[1].iWorkStep1 := iWorkStep_Axis;
astErrorHistory[1].iWorkStep2 := iWorkStep_Alghorithm;
astErrorHistory[1].udiErrorCode := ErrorCode;

iWorkStep_Alghorithm := iWorkStep_Axis := 90;
bAlg_Error := TRUE;
udiErrorCodeToRead := udiAlg_ErrorId := nEvent;
nActEvent := nEvent;
udiActErrorCode:= ErrorCode;
fbTON_WorkStepTime_Alg(IN := FALSE);
IF ErrorCode <> 0 THEN
	udiMcErrorToRead := udiMcError:= ErrorCode;
END_IF


bMeltingActive := bConnectingActive := bDetectCollision_Active := FALSE;
McReset.Execute := McHome.Execute := McStop.Execute := FALSE;
McJog.JogForward := McJog.JogBackwards := McMoveAbs.Execute := McMoveRel.Execute := McMoveVelocity.Execute := FALSE;
ACT_AxisFBs();]]></ST>
      </Implementation>
    </Method>
    <Method Name="mQuickHoming" Id="{a91d9f3b-86bc-44a1-9453-162ca41a81c2}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mQuickHoming : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
    <Method Name="mReadError" Id="{28268cb6-9192-4f04-895a-5a91a069c19a}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mReadError : BOOL
VAR_OUTPUT
	udiErrorID		: UDINT;
	udiMcErrorID	: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF udiErrorCodeToRead <> 0 THEN
	mReadError:= TRUE;
	udiErrorID := udiErrorCodeToRead;
	udiErrorCodeToRead := 0;
END_IF
IF udiMcErrorToRead <> 0 THEN
	mReadError:= TRUE;
	udiMcErrorID := udiMcErrorToRead;
	udiMcErrorToRead := 0;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="mReset" Id="{de486dab-4e3c-4086-8116-3d132568d40e}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mReset : BOOL
VAR_OUTPUT
	bBusy		: BOOL;
	bError		: BOOL;
	udiErrorId	: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF iWorkStep_Axis = 94 THEN
	iWorkStep_Axis := 95;
	bBusy := TRUE;
ELSIF iWorkStep_Axis = 95 THEN
	bBusy := TRUE;
ELSIF iWorkStep_Axis = 96 THEN
	iWorkStep_Axis := 5;
	mReset := TRUE;
ELSIF iWorkStep_Axis = 97 THEN
	mReset := TRUE;
	bError := TRUE;
	udiErrorId := McReset.ErrorID;
ELSIF iWorkStep_Axis = 5 OR iWorkStep_Axis = 10 THEN
	mReset := TRUE; 
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="mStartWelding" Id="{40294a0b-9218-4793-a9fb-ca4c8c6c5812}" FolderPath="Methods\">
      <Declaration><![CDATA[METHOD mStartWelding : BOOL
VAR_INPUT
	bHP_WorkPos				: BOOL;
	bHP_HomePos				: BOOL;
	rAdjDelay_ms			: REAL;
	bDepartureAfterHeatUp 	: BOOL;
	bConnectPermission 		: BOOL;
END_VAR
VAR_OUTPUT
	bBusy					: BOOL;
	bError					: BOOL;
	udiErrorId				: UDINT;
	bOpenHP					: BOOL;
	rAdjTime_ms				: REAL;
	bPartHeatedUp			: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF iWorkStep_Alghorithm >= 15 AND iWorkStep_Alghorithm < 90 THEN
	bHP_InWorkPos := bHP_WorkPos;
	bHP_InHomePos := bHP_HomePos;
	rMeltingDelay_ms := rAdjDelay_ms;
	bAllowToDepartAfterHeatUp := bDepartureAfterHeatUp;
	bStartConnecting := bConnectPermission;
	bOpenHP := iWorkStep_Alghorithm >= 16 AND iWorkStep_Alghorithm < 50;
	rAdjTime_ms := rMeltingTime;
	bPartHeatedUp := iWorkStep_Alghorithm >= 35;
	bBusy := TRUE;
	bError := bAlg_Error;
	udiErrorId := udiAlg_ErrorId;
	bWeldResultReaded:= FALSE;
	IF iWorkStep_Alghorithm = 70 THEN
		mStartWelding := TRUE;
		bWeldResultReaded:= TRUE;
	END_IF
ELSIF IsReady AND iWorkStep_Alghorithm = 10 THEN
	iWorkStep_Alghorithm := 15;
	bBusy := TRUE;			  
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Property Name="PartClamp" Id="{09561792-97eb-428d-914c-ab355c849fa6}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY PartClamp : BOOL]]></Declaration>
      <Get Name="Get" Id="{2b827eb1-f5fa-4709-bfb2-ed5a2ded4f85}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[PartClamp := stInOuts.bQ_PartLockPiston;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{1d64d957-d2ac-4df9-bcd6-7d6329a6582f}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[stInOuts.bQ_PartLockPiston := PartClamp;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="PartSensorState" Id="{8a9c6a35-7298-4d3b-bb33-88bb61e998c1}" FolderPath="Properties\">
      <Declaration><![CDATA[PROPERTY PartSensorState : BOOL]]></Declaration>
      <Get Name="Get" Id="{9e727c7f-87a9-48e3-b047-64f3e31fa23d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[PartSensorState := NOT stInOuts.bI_PartPresenceSensor;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="pCurrentPositionNumber" Id="{41825dbb-64b1-4e83-ae16-65ce953ed0d6}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribue 'monitoring':= call}
PROPERTY pCurrentPositionNumber : INT]]></Declaration>
      <Get Name="Get" Id="{be89d752-897f-42cc-9fb6-93f8381ec3fc}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[pCurrentPositionNumber:=iCurrentPositionNumber;]]></ST>
        </Implementation>
      </Get>
      <Set Name="Set" Id="{fa4da357-9ea8-46b3-8a53-5902ee487907}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[iCurrentPositionNumber:=pCurrentPositionNumber;]]></ST>
        </Implementation>
      </Set>
    </Property>
    <Property Name="pIsInTargetPosition" Id="{6a31859e-f0eb-4294-b495-5a5d7ff3f029}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribue 'monitoring':= call}
PROPERTY pIsInTargetPosition : BOOL]]></Declaration>
      <Get Name="Get" Id="{3e83d179-3d00-4ee8-9f37-dadc389ebe1b}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[pIsInTargetPosition := TRUE;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <Property Name="pIsNotMoving" Id="{01ff9134-a7fd-498c-a2ac-1ce718fdff1a}" FolderPath="Properties\">
      <Declaration><![CDATA[{attribue 'monitoring':= call}
PROPERTY pIsNotMoving : BOOL]]></Declaration>
      <Get Name="Get" Id="{e123ac62-4bb2-4463-91c7-a5e92913528d}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[pIsNotMoving := TRUE;]]></ST>
        </Implementation>
      </Get>
    </Property>
    <LineIds Name="FB_TableAxis">
      <LineId Id="3" Count="45" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.ACT_AxisFBs">
      <LineId Id="2" Count="38" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.ACT_AxisWorkSteps">
      <LineId Id="2" Count="279" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.ACT_BackgroundTasks">
      <LineId Id="2" Count="0" />
      <LineId Id="23" Count="0" />
      <LineId Id="25" Count="13" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.ACT_WeldingAlghorithm">
      <LineId Id="2" Count="91" />
      <LineId Id="407" Count="0" />
      <LineId Id="94" Count="23" />
      <LineId Id="409" Count="0" />
      <LineId Id="118" Count="25" />
      <LineId Id="412" Count="0" />
      <LineId Id="145" Count="9" />
      <LineId Id="413" Count="0" />
      <LineId Id="156" Count="150" />
      <LineId Id="464" Count="0" />
      <LineId Id="307" Count="61" />
      <LineId Id="414" Count="0" />
      <LineId Id="431" Count="1" />
      <LineId Id="434" Count="0" />
      <LineId Id="433" Count="0" />
      <LineId Id="437" Count="0" />
      <LineId Id="447" Count="4" />
      <LineId Id="458" Count="0" />
      <LineId Id="461" Count="0" />
      <LineId Id="465" Count="0" />
      <LineId Id="443" Count="0" />
      <LineId Id="445" Count="0" />
      <LineId Id="453" Count="4" />
      <LineId Id="459" Count="1" />
      <LineId Id="466" Count="0" />
      <LineId Id="452" Count="0" />
      <LineId Id="444" Count="0" />
      <LineId Id="370" Count="1" />
      <LineId Id="462" Count="1" />
      <LineId Id="467" Count="0" />
      <LineId Id="372" Count="17" />
      <LineId Id="468" Count="0" />
      <LineId Id="391" Count="0" />
      <LineId Id="484" Count="2" />
      <LineId Id="483" Count="0" />
      <LineId Id="392" Count="2" />
      <LineId Id="481" Count="1" />
      <LineId Id="487" Count="1" />
      <LineId Id="395" Count="1" />
      <LineId Id="476" Count="0" />
      <LineId Id="397" Count="0" />
      <LineId Id="489" Count="6" />
      <LineId Id="478" Count="0" />
      <LineId Id="496" Count="0" />
      <LineId Id="398" Count="8" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.ActualForce.Get">
      <LineId Id="3" Count="3" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.ActualPosition.Get">
      <LineId Id="3" Count="3" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.ActualPresetPosition.Get">
      <LineId Id="3" Count="29" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.ActualVelocity.Get">
      <LineId Id="3" Count="3" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.Enabled.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.Enabled.Set">
      <LineId Id="3" Count="13" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.InSetPos_ConnPos.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.InSetPos_MarkingPos.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.InSetPos_MaxPos.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.InSetPos_MinPos.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.InSetPos_PartLoad.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.InSetPos_SafeHpMove.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.IsCalibrated.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.IsCalibrated.Set">
      <LineId Id="3" Count="1" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.IsErrorActive.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.IsHomed.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.IsMoving.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.IsReady.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.IsReadyForOperation.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.IsSafeToMoveHP.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.mAddTimeStat">
      <LineId Id="3" Count="2" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.ManualMode.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.ManualMode.Set">
      <LineId Id="3" Count="16" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.mCalibrateAxis">
      <LineId Id="3" Count="23" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.mGoToSafeState">
      <LineId Id="3" Count="11" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.mHomeAxis">
      <LineId Id="3" Count="12" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.mManualMove">
      <LineId Id="3" Count="29" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.mMoveFastToPresetPos">
      <LineId Id="3" Count="30" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.mMoveToAbsPos">
      <LineId Id="3" Count="18" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.mNewEvent">
      <LineId Id="3" Count="21" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.mQuickHoming">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.mReadError">
      <LineId Id="3" Count="8" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.mReset">
      <LineId Id="3" Count="13" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.mStartWelding">
      <LineId Id="3" Count="20" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.PartClamp.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.PartClamp.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.PartSensorState.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.pCurrentPositionNumber.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.pCurrentPositionNumber.Set">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.pIsInTargetPosition.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_TableAxis.pIsNotMoving.Get">
      <LineId Id="2" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>